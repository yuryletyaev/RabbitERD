<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RabbitMQ ERD Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="/static/css/style.css">
    <style>
        .filters {
            display: flex;
            gap: 20px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .filter-group label {
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }
        
        .filter-group select {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .exchange-block {
            cursor: pointer;
        }
        
        .route {
            cursor: pointer;
        }
        
        .queue {
            cursor: pointer;
        }
        
        .exchange-block:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 3 !important;
        }
        
        .route:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 2 !important;
        }
        
        .queue:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 2 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>RabbitMQ ERD Visualizer</h1>
            <div class="controls">
                <button id="refreshBtn" class="btn">Обновить</button>
                <button id="zoomInBtn" class="btn">+</button>
                <button id="zoomOutBtn" class="btn">-</button>
            </div>
        </header>
        
        <div class="info-panel">
            <div class="stats">
                <div class="stat-item">
                    <span class="label">Обмены:</span>
                    <span class="value" id="exchangeCount">{{ topology.exchanges|length }}</span>
                </div>
                <div class="stat-item">
                    <span class="label">Очереди:</span>
                    <span class="value" id="queueCount">{{ topology.queues|length }}</span>
                </div>
                <div class="stat-item">
                    <span class="label">Связи:</span>
                    <span class="value" id="connectionCount">{{ topology.connections|length }}</span>
                </div>
            </div>
            <div class="filters">
                <div class="filter-group">
                    <label>Фильтр по обменам:</label>
                    <select id="exchangeFilter">
                        <option value="">Все обмены</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Фильтр по роутам:</label>
                    <select id="routeFilter">
                        <option value="">Все роуты</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Фильтр по очередям:</label>
                    <select id="queueFilter">
                        <option value="">Все очереди</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="visualization-container">
            <svg id="diagram" width="100%" height="600"></svg>
        </div>
        
        <div class="details-panel" id="detailsPanel" style="display: none;">
            <h3>Детали</h3>
            <div id="detailsContent"></div>
        </div>
    </div>
    
    <script>
        // Данные топологии
        const topology = {{ topology | tojson }};
        
        // Конфигурация
        const config = {
            blockWidth: 300,
            blockHeight: 200,
            routeHeight: 40,
            queueHeight: 30,
            colors: {
                exchange: '#4CAF50',
                route: '#FF9800',
                queue: '#2196F3',
                connection: '#666'
            }
        };
        
        // Глобальные переменные
        let svg, g, zoom;
        let currentFilters = {
            exchange: '',
            route: '',
            queue: ''
        };
        
        // Инициализация визуализации
        function initVisualization() {
            try {
                svg = d3.select('#diagram');
                g = svg.append('g');
                
                zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                
                updateVisualization();
                setupFilters();
            } catch (error) {
                console.error('Ошибка инициализации:', error);
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка инициализации</h2><p>' + error.message + '</p>';
            }
        }
        
        // Обновление визуализации
        function updateVisualization() {
            try {
                if (!topology) {
                    console.error('Данные топологии не загружены');
                    return;
                }
                
                g.selectAll('*').remove();
                
                const exchanges = topology.exchanges || [];
                const queues = topology.queues || [];
                const bindings = topology.bindings || [];
                
                if (exchanges.length === 0) {
                    g.append('text')
                        .attr('x', '50%')
                        .attr('y', '50%')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '0.35em')
                        .attr('font-size', '18px')
                        .attr('fill', '#666')
                        .text('Нет данных для отображения');
                    return;
                }
                
                // Создаем структуру данных
                const exchangeBlocks = createExchangeBlocks(exchanges, queues, bindings);
                
                // Фильтруем данные
                const filteredBlocks = filterBlocks(exchangeBlocks);
                
                // Рисуем блоки
                drawExchangeBlocks(filteredBlocks);
                
            } catch (error) {
                console.error('Ошибка обновления визуализации:', error);
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка визуализации</h2><p>' + error.message + '</p></div>';
            }
        }
        
        // Создание блоков обменов
        function createExchangeBlocks(exchanges, queues, bindings) {
            return exchanges.map((exchange, index) => {
                // Находим связанные очереди через bindings
                const relatedBindings = bindings.filter(binding => 
                    binding.source === exchange.name || binding.destination === exchange.name
                );
                
                // Группируем по роутам (routing_key)
                const routes = {};
                relatedBindings.forEach(binding => {
                    const routeKey = binding.routing_key || 'default';
                    if (!routes[routeKey]) {
                        routes[routeKey] = [];
                    }
                    routes[routeKey].push(binding);
                });
                
                // Создаем структуру роутов
                const routeList = Object.keys(routes).map(routeKey => {
                    const routeBindings = routes[routeKey];
                    const routeQueues = routeBindings.map(binding => {
                        const queueName = binding.destination === exchange.name ? 
                            binding.source : binding.destination;
                        return queues.find(q => q.name === queueName);
                    }).filter(q => q);
                    
                    return {
                        name: routeKey,
                        queues: routeQueues,
                        bindings: routeBindings
                    };
                });
                
                return {
                    exchange: exchange,
                    routes: routeList,
                    x: 50 + (index % 3) * 350,
                    y: 50 + Math.floor(index / 3) * 250
                };
            });
        }
        
        // Фильтрация блоков
        function filterBlocks(blocks) {
            return blocks.filter(block => {
                if (currentFilters.exchange && block.exchange.name !== currentFilters.exchange) {
                    return false;
                }
                
                if (currentFilters.route) {
                    const hasMatchingRoute = block.routes.some(route => 
                        route.name === currentFilters.route
                    );
                    if (!hasMatchingRoute) return false;
                }
                
                if (currentFilters.queue) {
                    const hasMatchingQueue = block.routes.some(route =>
                        route.queues.some(queue => queue.name === currentFilters.queue)
                    );
                    if (!hasMatchingQueue) return false;
                }
                
                return true;
            });
        }
        
        // Рисование блоков обменов
        function drawExchangeBlocks(blocks) {
            const blockGroups = g.append('g')
                .attr('class', 'exchange-blocks')
                .selectAll('g')
                .data(blocks)
                .enter().append('g')
                .attr('class', 'exchange-block')
                .attr('transform', d => `translate(${d.x}, ${d.y})`);
            
            // Рисуем основной блок обмена
            blockGroups.append('rect')
                .attr('width', config.blockWidth)
                .attr('height', config.blockHeight)
                .attr('rx', 10)
                .attr('fill', config.colors.exchange)
                .attr('stroke', '#333')
                .attr('stroke-width', 2);
            
            // Заголовок обмена
            blockGroups.append('text')
                .attr('x', config.blockWidth / 2)
                .attr('y', 25)
                .attr('text-anchor', 'middle')
                .attr('fill', 'white')
                .attr('font-weight', 'bold')
                .attr('font-size', '14px')
                .text(d => d.exchange.name);
            
            // Рисуем роуты
            let routeY = 50;
            blocks.forEach(block => {
                block.routes.forEach((route, routeIndex) => {
                    const routeGroup = blockGroups.filter(d => d === block)
                        .append('g')
                        .attr('class', 'route')
                        .attr('transform', `translate(10, ${routeY})`);
                    
                    // Роут
                    routeGroup.append('rect')
                        .attr('width', config.blockWidth - 20)
                        .attr('height', config.routeHeight)
                        .attr('rx', 5)
                        .attr('fill', config.colors.route)
                        .attr('stroke', '#333')
                        .attr('stroke-width', 1);
                    
                    routeGroup.append('text')
                        .attr('x', 10)
                        .attr('y', 20)
                        .attr('fill', 'white')
                        .attr('font-size', '12px')
                        .text(`Route: ${route.name}`);
                    
                    // Очереди
                    let queueY = 45;
                    route.queues.forEach((queue, queueIndex) => {
                        const queueGroup = routeGroup.append('g')
                            .attr('class', 'queue')
                            .attr('transform', `translate(20, ${queueY})`);
                        
                        queueGroup.append('rect')
                            .attr('width', config.blockWidth - 40)
                            .attr('height', config.queueHeight)
                            .attr('rx', 3)
                            .attr('fill', config.colors.queue)
                            .attr('stroke', '#333')
                            .attr('stroke-width', 1);
                        
                        queueGroup.append('text')
                            .attr('x', 10)
                            .attr('y', 18)
                            .attr('fill', 'white')
                            .attr('font-size', '10px')
                            .text(queue.name);
                        
                        queueY += 35;
                    });
                    
                    routeY += 50 + (route.queues.length * 35);
                });
            });
        }
        
        // Настройка фильтров
        function setupFilters() {
            const exchanges = topology.exchanges || [];
            const queues = topology.queues || [];
            const bindings = topology.bindings || [];
            
            // Заполняем фильтр обменов
            const exchangeFilter = document.getElementById('exchangeFilter');
            exchanges.forEach(exchange => {
                const option = document.createElement('option');
                option.value = exchange.name;
                option.textContent = exchange.name;
                exchangeFilter.appendChild(option);
            });
            
            // Заполняем фильтр очередей
            const queueFilter = document.getElementById('queueFilter');
            queues.forEach(queue => {
                const option = document.createElement('option');
                option.value = queue.name;
                option.textContent = queue.name;
                queueFilter.appendChild(option);
            });
            
            // Заполняем фильтр роутов
            const routeFilter = document.getElementById('routeFilter');
            const routes = new Set();
            bindings.forEach(binding => {
                if (binding.routing_key) {
                    routes.add(binding.routing_key);
                }
            });
            routes.forEach(route => {
                const option = document.createElement('option');
                option.value = route;
                option.textContent = route;
                routeFilter.appendChild(option);
            });
            
            // Обработчики фильтров
            exchangeFilter.addEventListener('change', (e) => {
                currentFilters.exchange = e.target.value;
                updateVisualization();
            });
            
            routeFilter.addEventListener('change', (e) => {
                currentFilters.route = e.target.value;
                updateVisualization();
            });
            
            queueFilter.addEventListener('change', (e) => {
                currentFilters.queue = e.target.value;
                updateVisualization();
            });
        }
        
        // Обработчики кнопок
        document.getElementById('refreshBtn').addEventListener('click', () => {
            updateVisualization();
        });
        
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            if (svg && zoom) {
                svg.transition().call(zoom.scaleBy, 1.5);
            }
        });
        
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            if (svg && zoom) {
                svg.transition().call(zoom.scaleBy, 1 / 1.5);
            }
        });
        
        // Инициализация при загрузке страницы
        window.addEventListener('load', () => {
            if (typeof d3 !== 'undefined') {
                initVisualization();
            } else {
                console.error('D3.js не загружен');
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка загрузки D3.js</h2><p>Библиотека D3.js не загружена</p></div>';
            }
        });
    </script>
</body>
</html>
