<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RabbitMQ ERD Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="/static/css/style.css">
    <style>
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            background: #f7f7f7;
            border-bottom: 1px solid #e5e5e5;
        }

        header h1 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }

        header .controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        header .controls .btn {
            padding: 4px 8px;
            font-size: 12px;
            line-height: 1.2;
        }
        /* Видимость плейсхолдеров и удобство ввода */
        .filters input[type="text"] {
            height: 32px;
            line-height: 20px;
            padding: 6px 10px;
            font-size: 14px;
            box-sizing: border-box;
            width: 220px;
            /* Полностью скрываем datalist */
            list-style: none;
        }
        
        /* Скрываем datalist полностью */
        .filters datalist {
            display: none !important;
        }

        .filter-group {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 1;
        }

        .filter-input-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .filter-reset, .filter-open {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border: 1px solid #ccc;
            background: #fff;
            color: #666;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
        }

        .filter-reset:hover, .filter-open:hover {
            background: #f0f0f0;
        }
        
        /* Кастомный выпадающий список */
        .custom-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 2px;
        }
        
        .custom-dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 14px;
            line-height: 1.4;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .custom-dropdown-item:hover {
            background: #f0f0f0;
        }
        
        .custom-dropdown-item:last-child {
            border-bottom: none;
        }
        
        /* Подсветка совпадений */
        .custom-dropdown-item.highlighted {
            background: #e3f2fd;
            border-left: 3px solid #2196f3;
        }
        
        .custom-dropdown-item.highlighted:hover {
            background: #bbdefb;
        }
        
        /* Стили для автодополнения */
        .filter-input-row {
            position: relative;
        }
        
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ccc;
            border-top: none;
            border-radius: 0 0 4px 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }
        
        .autocomplete-suggestion {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 14px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.highlighted {
            background: #e3f2fd;
        }
        
        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }
        .stats-container {
            margin: 10px 0;
            background: #f0f8ff;
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
        }
        
        .stats-header {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 10px;
            background: #e0f0ff;
            border-bottom: 1px solid #ddd;
        }
        
        .stats-header:hover {
            background: #d0e0ff;
        }
        
        .stats-toggle {
            font-size: 16px;
            transition: transform 0.3s ease;
        }
        
        .stats-toggle.collapsed {
            transform: rotate(-90deg);
        }
        
        .stats {
            display: flex;
            gap: 20px;
            padding: 15px;
            flex-wrap: wrap;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .stats.collapsed {
            max-height: 0;
            padding: 0 15px;
        }
        
        .filters-container {
            margin: 10px 0;
            background: #f5f5f5;
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: visible;
        }
        
        .filters-header {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 10px;
            background: #e5e5e5;
            border-bottom: 1px solid #ddd;
        }
        
        .filters-header:hover {
            background: #d5d5d5;
        }
        
        .filters-toggle {
            font-size: 16px;
            transition: transform 0.3s ease;
        }
        
        .filters-toggle.collapsed {
            transform: rotate(-90deg);
        }
        
        .filters {
            display: flex;
            gap: 20px;
            padding: 15px;
            margin: 10px 0;
            flex-wrap: wrap;
            transition: all 0.3s ease;
            overflow: visible;
        }
        
        .filters.collapsed {
            max-height: 0;
            margin: 0;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .filter-group label {
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }
        
        .filter-group select {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .exchange-block {
            cursor: pointer;
        }
        
        .route {
            cursor: pointer;
        }
        
        .queue {
            cursor: pointer;
        }
        
        .exchange-block:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 3 !important;
        }
        
        .route:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 2 !important;
        }
        
        .queue:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 2 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>RabbitMQ Visualizer</h1>
            <div class="controls">
                <button id="refreshBtn" class="btn">Оцентровать диаграмму</button>
                <button id="zoomInBtn" class="btn">+</button>
                <button id="zoomOutBtn" class="btn">-</button>
            </div>
        </header>
        
        <div class="stats-container">
            <div class="stats-header" onclick="toggleStats()">
                <span class="stats-toggle" id="statsToggle">▼</span>
                <span>Статистика</span>
            </div>
            <div class="stats" id="stats">
                <div class="stat-item">
                    <span class="label">VirtualHost:</span>
                    <span class="value" id="virtualHostCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="label">Exchange:</span>
                    <span class="value" id="exchangeCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="label">Queue:</span>
                    <span class="value" id="queueCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="label">Route:</span>
                    <span class="value" id="routeCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="label">Route multiple consumer:</span>
                    <span class="value" id="multiQueueRouteCount">0</span>
                </div>
            </div>
        </div>
            <div class="filters-container">
                <div class="filters-header" onclick="toggleFilters()">
                    <span class="filters-toggle" id="filtersToggle">▼</span>
                    <span>Фильтры</span>
                </div>
                <div class="filters" id="filters">
                    <div class="filter-group">
                        <label for="virtualHostFilter">VirtualHost:</label>
                        <div class="filter-input-row">
                            <input type="text" id="virtualHostFilter">
                            <button type="button" id="virtualHostOpen" class="filter-open" title="Открыть список" aria-label="Открыть список">▾</button>
                            <button type="button" id="virtualHostReset" class="filter-reset" title="Сбросить VirtualHost" aria-label="Сбросить VirtualHost">×</button>
                            <div class="autocomplete-suggestions" id="virtualHostAutocomplete"></div>
                        </div>
                        <div class="custom-dropdown" id="virtualHostDropdown" style="display: none;"></div>
                    </div>
                    <div class="filter-group">
                        <label for="exchangeFilter">Exchange:</label>
                        <div class="filter-input-row">
                            <input type="text" id="exchangeFilter">
                            <button type="button" id="exchangeOpen" class="filter-open" title="Открыть список" aria-label="Открыть список">▾</button>
                            <button type="button" id="exchangeReset" class="filter-reset" title="Сбросить Exchange" aria-label="Сбросить Exchange">×</button>
                            <div class="autocomplete-suggestions" id="exchangeAutocomplete"></div>
                        </div>
                        <div class="custom-dropdown" id="exchangeDropdown" style="display: none;"></div>
                    </div>
                    <div class="filter-group">
                        <label for="routeFilter">RoutingKey:</label>
                        <div class="filter-input-row">
                            <input type="text" id="routeFilter">
                            <button type="button" id="routeOpen" class="filter-open" title="Открыть список" aria-label="Открыть список">▾</button>
                            <button type="button" id="routeReset" class="filter-reset" title="Сбросить RoutingKey" aria-label="Сбросить RoutingKey">×</button>
                            <div class="autocomplete-suggestions" id="routeAutocomplete"></div>
                        </div>
                        <div class="custom-dropdown" id="routeDropdown" style="display: none;"></div>
                    </div>
                    <div class="filter-group">
                        <label for="queueFilter">Queue:</label>
                        <div class="filter-input-row">
                            <input type="text" id="queueFilter">
                            <button type="button" id="queueOpen" class="filter-open" title="Открыть список" aria-label="Открыть список">▾</button>
                            <button type="button" id="queueReset" class="filter-reset" title="Сбросить Queue" aria-label="Сбросить Queue">×</button>
                            <div class="autocomplete-suggestions" id="queueAutocomplete"></div>
                        </div>
                        <div class="custom-dropdown" id="queueDropdown" style="display: none;"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="visualization-container">
            <svg id="diagram" width="100%" height="600"></svg>
        </div>
        
        <div class="details-panel" id="detailsPanel" style="display: none;">
            <h3>Детали</h3>
            <div id="detailsContent"></div>
        </div>
    </div>
    
    <!-- Скрытые данные топологии -->
    <script type="application/json" id="topologyData">{{ topology | tojson }}</script>
    
    <script>
        // Данные топологии
        const topologyData = document.getElementById('topologyData').textContent;
        const topology = JSON.parse(topologyData);
        
        // Конфигурация
        const config = {
            virtualHostWidth: 400,
            virtualHostHeight: 400,
            blockWidth: 300,
            blockHeight: 300,
            routeHeight: 35,
            queueHeight: 25,
            colors: {
                virtualHost: 'transparent',
                exchange: 'transparent',
                route: '#FF9800',
                queue: '#2196F3',
                connection: '#666'
            }
        };
        
        // Глобальные переменные
        let svg, g, zoom;
        let currentFilters = {
            virtualHost: '',
            exchange: '',
            route: '',
            queue: ''
        };
        
        // Инициализация визуализации
        function initVisualization() {
            try {
                svg = d3.select('#diagram');
                g = svg.append('g');
                
                zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                
                updateVisualization();
            } catch (error) {
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка инициализации</h2><p>' + error.message + '</p>';
            }
        }
        
        // Обновление визуализации
        function updateVisualization() {
            try {
                if (!topology) {
                    return;
                }
                
                
                g.selectAll('*').remove();
                
                const exchanges = topology.exchanges || [];
                const queues = topology.queues || [];
                const bindings = topology.bindings || [];
                
                
                if (exchanges.length === 0 && queues.length === 0) {
                    g.append('text')
                        .attr('x', '50%')
                        .attr('y', '50%')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '0.35em')
                        .attr('font-size', '18px')
                        .attr('fill', '#666')
                        .text('Нет данных для отображения');
                    return;
                }
                
                // Создаем структуру данных
                const virtualHostBlocks = createVirtualHostBlocks(exchanges, queues, bindings);
                
                // Фильтруем данные
                const filteredBlocks = filterVirtualHostBlocks(virtualHostBlocks);
                
                // Сохраняем блоки для статистики
                window.currentFilteredBlocks = filteredBlocks;
                
                // Рисуем блоки
                drawVirtualHostBlocks(filteredBlocks);
                
                // Настраиваем фильтры после обновления данных
                setupFilters();
                
                // Обновляем статистику
                updateStats();
                
            } catch (error) {
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка визуализации</h2><p>' + error.message + '</p></div>';
            }
        }
        
        // Создание блоков VirtualHost
        function createVirtualHostBlocks(exchanges, queues, bindings) {
            try {
                
                // Группируем по VirtualHost
                const virtualHosts = {};
            
            // Добавляем exchanges в VirtualHost
            exchanges.forEach(exchange => {
                // Пропускаем Exchange с пустыми именами
                if (!exchange.name || exchange.name.trim() === '') {
                    return;
                }
                
                const vhost = exchange.vhost || '/';
                if (!virtualHosts[vhost]) {
                    virtualHosts[vhost] = {
                        name: vhost,
                        exchanges: []
                    };
                }
                virtualHosts[vhost].exchanges.push(exchange);
            });
            
            // Добавляем queues в VirtualHost
            queues.forEach(queue => {
                const vhost = queue.vhost || '/';
                if (!virtualHosts[vhost]) {
                    virtualHosts[vhost] = {
                        name: vhost,
                        exchanges: []
                    };
                }
            });
            
            // Создаем структуру для каждого VirtualHost
            return Object.values(virtualHosts).map((vhost, index) => {
                const vhostExchanges = vhost.exchanges.map(exchange => {
                    // Находим связанные очереди через bindings в том же VirtualHost
                    // В RabbitMQ binding: source = exchange, destination = queue
                    const relatedBindings = bindings.filter(binding => 
                        binding.source === exchange.name && binding.vhost === exchange.vhost
                    );
                    
                    // Группируем по роутам (routing_key)
                    const routes = {};
                    relatedBindings.forEach(binding => {
                        const routeKey = binding.routing_key || 'default';
                        if (!routes[routeKey]) {
                            routes[routeKey] = [];
                        }
                        routes[routeKey].push(binding);
                    });
                    
                    // Создаем структуру роутов
                    const routeList = Object.keys(routes).map(routeKey => {
                        const routeBindings = routes[routeKey];
                        const routeQueues = routeBindings.map(binding => {
                            // В RabbitMQ binding: source = exchange, destination = queue
                            const queueName = binding.destination;
                            // Ищем очередь в том же VirtualHost, что и exchange
                            return queues.find(q => q.name === queueName && q.vhost === exchange.vhost);
                        }).filter(q => q);
                        
                        return {
                            name: routeKey,
                            queues: routeQueues,
                            bindings: routeBindings,
                            queueCount: routeQueues.length
                        };
                    });
                    
                    // Для каждого роута устанавливаем максимальное количество очередей в этом роуте
                    routeList.forEach(route => {
                        route.maxQueuesInRoute = route.queueCount; // Максимум очередей в этом конкретном роуте
                    });
                    
                    return {
                        exchange: exchange,
                        routes: routeList
                    };
                });
                
                return {
                    virtualHost: vhost,
                    exchanges: vhostExchanges,
                    x: 0, // Будет пересчитано в drawVirtualHostBlocks
                    y: 50
                };
            });
            
            return Object.values(virtualHosts);
            
            } catch (error) {
                return [];
            }
        }
        
        // Фильтрация блоков VirtualHost
        function filterVirtualHostBlocks(blocks) {
            
            const filtered = blocks.map(block => {
                // Фильтруем VirtualHost по имени
                if (currentFilters.virtualHost && block.virtualHost.name !== currentFilters.virtualHost) {
                    return null;
                }
                
                // Фильтруем exchanges внутри блока
                const filteredExchanges = block.exchanges.filter(exchange => {
                    // Исключаем Exchange с пустыми именами
                    if (!exchange.exchange.name || exchange.exchange.name.trim() === '') {
                        return false;
                    }
                    
                    // Фильтр по exchange
                    if (currentFilters.exchange && exchange.exchange.name !== currentFilters.exchange) {
                        return false;
                    }
                    
                    // Фильтруем routes внутри exchange
                    const filteredRoutes = exchange.routes.filter(route => {
                        // Фильтр по route
                        if (currentFilters.route && route.name !== currentFilters.route) {
                            return false;
                        }
                        
                        // Фильтруем queues внутри route
                        const filteredQueues = route.queues.filter(queue => {
                            // Фильтр по queue
                            if (currentFilters.queue && queue.name !== currentFilters.queue) {
                                return false;
                            }
                            return true;
                        });
                        
                        // Обновляем queues в route
                        route.queues = filteredQueues;
                        
                        // Пересчитываем количество очередей в роуте после фильтрации
                        route.queueCount = filteredQueues.length;
                        route.maxQueuesInRoute = filteredQueues.length;
                        
                        // Возвращаем route только если в нем есть очереди после фильтрации
                        return filteredQueues.length > 0;
                    });
                    
                    // Обновляем routes в exchange
                    exchange.routes = filteredRoutes;
                    
                    // Возвращаем exchange только если в нем есть routes после фильтрации
                    return filteredRoutes.length > 0;
                });
                
                // Обновляем exchanges в блоке
                block.exchanges = filteredExchanges;
                
                // Возвращаем блок только если в нем есть exchanges после фильтрации
                return filteredExchanges.length > 0 ? block : null;
            }).filter(block => block !== null);
            
            return filtered;
        }
        
        // Рисование блоков VirtualHost
        function drawVirtualHostBlocks(blocks) {
            try {
                
                if (!blocks || !Array.isArray(blocks)) {
                    return;
                }
                
                // Сначала рассчитываем размеры всех блоков и их позиции
                let currentX = 50; // Начальная позиция
                
                blocks.forEach((block, blockIndex) => {
                    // Рассчитываем высоту на основе содержимого (максимальная высота среди всех exchanges)
                    let maxHeight = 80; // Заголовок + отступы
                    let totalWidth = 40; // Отступы
                    
                    block.exchanges.forEach(exchangeData => {
                        // Рассчитываем размеры exchange на основе содержимого
                        let exchangeWidth = 200; // Минимальная ширина
                        let exchangeHeight = 50; // Высота заголовка
                        
                        // Учитываем длину названия Exchange
                        const exchangeNameWidth = Math.max(200, exchangeData.exchange.name.length * 8 + 100);
                        exchangeWidth = Math.max(exchangeWidth, exchangeNameWidth);
                        
                        exchangeData.routes.forEach(route => {
                            const routeWidth = Math.max(150, route.name.length * 8 + 100);
                            exchangeWidth = Math.max(exchangeWidth, routeWidth + 20);
                            
                            exchangeHeight += 40; // Высота route
                            
                            route.queues.forEach(queue => {
                                const queueWidth = Math.max(100, queue.name.length * 6 + 80);
                                exchangeWidth = Math.max(exchangeWidth, queueWidth + 40);
                                
                                exchangeHeight += 30; // Высота очереди
                            });
                        });
                        
                        // Обновляем общие размеры VirtualHost
                        maxHeight = Math.max(maxHeight, exchangeHeight + 80);
                        totalWidth += exchangeWidth + 20; // Ширина exchange + отступ
                    });
                    
                    // Устанавливаем позицию и размеры блока
                    block.x = currentX;
                    block.y = 50;
                    block.width = totalWidth;
                    block.height = maxHeight;
                    
                    // Переходим к следующему блоку
                    currentX += totalWidth + 50; // Ширина блока + отступ
                });
                
                // Теперь создаем SVG элементы
                const virtualHostGroups = g.append('g')
                    .attr('class', 'virtualhost-blocks')
                    .selectAll('g')
                    .data(blocks)
                    .enter().append('g')
                    .attr('class', 'virtualhost-block')
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);
                
                // Рисуем блоки VirtualHost
                blocks.forEach((block, blockIndex) => {
                    const currentVirtualHostGroup = virtualHostGroups.filter(d => d === block);
                    
                    // Рисуем основной блок VirtualHost с рассчитанными размерами
                    currentVirtualHostGroup.append('rect')
                        .attr('width', block.width)
                        .attr('height', block.height)
                        .attr('rx', 15)
                        .attr('fill', config.colors.virtualHost)
                        .attr('stroke', '#333')
                        .attr('stroke-width', 3);
                    
                    // Заголовок VirtualHost
                    currentVirtualHostGroup.append('text')
                        .attr('x', block.width / 2)
                        .attr('y', 30)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#333')
                        .attr('font-weight', 'bold')
                        .attr('font-size', '16px')
                        .text(`VirtualHost: ${block.virtualHost.name}`);
                });
                
                // Рисуем содержимое для каждого VirtualHost отдельно
                blocks.forEach((block, blockIndex) => {
                    const currentVirtualHostGroup = virtualHostGroups.filter(d => d === block);
                    let exchangeX = 20;
                    
                    block.exchanges.forEach((exchangeData, exchangeIndex) => {
                        // Используем уже рассчитанные размеры из первого прохода
                        let exchangeWidth = 200; // Минимальная ширина
                        let exchangeHeight = 50; // Высота заголовка
                        
                        // Учитываем длину названия Exchange
                        const exchangeNameWidth = Math.max(200, exchangeData.exchange.name.length * 8 + 100);
                        exchangeWidth = Math.max(exchangeWidth, exchangeNameWidth);
                        
                        exchangeData.routes.forEach(route => {
                            const routeWidth = Math.max(150, route.name.length * 8 + 100);
                            exchangeWidth = Math.max(exchangeWidth, routeWidth + 20);
                            
                            exchangeHeight += 40; // Высота route
                            
                            route.queues.forEach(queue => {
                                const queueWidth = Math.max(100, queue.name.length * 6 + 80);
                                exchangeWidth = Math.max(exchangeWidth, queueWidth + 40);
                                
                                exchangeHeight += 30; // Высота очереди
                            });
                        });
                        
                        const exchangeGroup = currentVirtualHostGroup.append('g')
                            .attr('class', 'exchange')
                            .attr('transform', `translate(${exchangeX}, 60)`);
                        
                        // Exchange с рассчитанными размерами
                        exchangeGroup.append('rect')
                            .attr('width', exchangeWidth)
                            .attr('height', exchangeHeight)
                            .attr('rx', 10)
                            .attr('fill', config.colors.exchange)
                            .attr('stroke', '#333')
                            .attr('stroke-width', 2);
                        
                        exchangeGroup.append('text')
                            .attr('x', 10)
                            .attr('y', 25)
                            .attr('fill', '#333')
                            .attr('font-weight', 'bold')
                            .attr('font-size', '14px')
                            .text(`Exchange: ${exchangeData.exchange.name || '(без имени)'}`);
                        
                        // Рисуем роуты для каждого exchange
                        let routeY = 50;
                        exchangeData.routes.forEach((route, routeIndex) => {
                            const routeGroup = exchangeGroup.append('g')
                                .attr('class', 'route')
                                .attr('transform', `translate(10, ${routeY})`);
                            
                            // Роут
                            routeGroup.append('rect')
                                .attr('width', exchangeWidth - 20)
                                .attr('height', config.routeHeight)
                                .attr('rx', 5)
                                .attr('fill', config.colors.route)
                                .attr('stroke', '#333')
                                .attr('stroke-width', 1);
                            
                            routeGroup.append('text')
                                .attr('x', 10)
                                .attr('y', 20)
                                .attr('fill', 'white')
                                .attr('font-size', '12px')
                                .attr('style', 'user-select: text; cursor: text;')
                                .text(`RoutingKey: ${route.name}`);
                            
                            // Очереди
                            let queueY = 40;
                            route.queues.forEach((queue, queueIndex) => {
                                const queueGroup = routeGroup.append('g')
                                    .attr('class', 'queue')
                                    .attr('transform', `translate(20, ${queueY})`);
                                
                                // Рассчитываем цвет на основе количества очередей в роуте
                                const queueColor = getQueueColor(route.queueCount, route.maxQueuesInRoute);
                                
                                queueGroup.append('rect')
                                    .attr('width', exchangeWidth - 40)
                                    .attr('height', config.queueHeight)
                                    .attr('rx', 3)
                                    .attr('fill', queueColor)
                                    .attr('stroke', '#333')
                                    .attr('stroke-width', 1);
                                
                                queueGroup.append('text')
                                    .attr('x', 10)
                                    .attr('y', 16)
                                    .attr('fill', 'white')
                                    .attr('font-size', '10px')
                                    .attr('style', 'user-select: text; cursor: text;')
                                    .text(queue.name);
                                
                                queueY += 30;
                            });
                            
                            // Переходим к следующему роуту
                            routeY += 40 + (route.queues.length * 30);
                        });
                        
                        // Переходим к следующему exchange горизонтально
                        exchangeX += exchangeWidth + 20;
                    });
                });
            } catch (error) {
                g.append('text')
                    .attr('x', '50%')
                    .attr('y', '50%')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .attr('font-size', '16px')
                    .attr('fill', '#ff0000')
                    .text('Ошибка отображения блоков');
            }
        }
        
        // Функция для расчета цвета очереди на основе количества очередей в роуте
        function getQueueColor(queueCount, maxQueuesInRoute) {
            if (maxQueuesInRoute <= 1) {
                return '#2196F3'; // Светло-синий для одного элемента
            }
            
            // Рассчитываем интенсивность от 0.3 (светлый) до 1.0 (темный)
            // queueCount всегда равен maxQueuesInRoute для одного роута, поэтому используем фиксированную интенсивность
            const intensity = 0.3 + (0.7 * Math.min(queueCount / 5, 1)); // Максимум при 5+ очередях
            
            // Конвертируем в RGB
            const blue = Math.floor(243 * intensity);
            const green = Math.floor(150 * intensity);
            const red = Math.floor(33 * intensity);
            
            return `rgb(${red}, ${green}, ${blue})`;
        }
        
        // Функция для сворачивания статистики
        function toggleStats() {
            const stats = document.getElementById('stats');
            const toggle = document.getElementById('statsToggle');
            
            if (stats.classList.contains('collapsed')) {
                stats.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                stats.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }
        
        // Функция для сворачивания фильтров
        function toggleFilters() {
            const filters = document.getElementById('filters');
            const toggle = document.getElementById('filtersToggle');
            
            if (filters.classList.contains('collapsed')) {
                filters.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                filters.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }
        
        // Обновление статистики
        function updateStats() {
            try {
                const exchanges = topology.exchanges || [];
                const queues = topology.queues || [];
                const bindings = topology.bindings || [];
                
                // Применяем фильтры к данным для статистики
                const filteredExchanges = exchanges.filter(exchange => {
                    if (currentFilters.virtualHost && exchange.vhost !== currentFilters.virtualHost) {
                        return false;
                    }
                    if (currentFilters.exchange && exchange.name !== currentFilters.exchange) {
                        return false;
                    }
                    return true;
                });
                
                const filteredQueues = queues.filter(queue => {
                    if (currentFilters.virtualHost && queue.vhost !== currentFilters.virtualHost) {
                        return false;
                    }
                    if (currentFilters.queue && queue.name !== currentFilters.queue) {
                        return false;
                    }
                    return true;
                });
                
                const filteredBindings = bindings.filter(binding => {
                    if (currentFilters.virtualHost && binding.vhost !== currentFilters.virtualHost) {
                        return false;
                    }
                    if (currentFilters.exchange && binding.source !== currentFilters.exchange) {
                        return false;
                    }
                    if (currentFilters.route && binding.routing_key !== currentFilters.route) {
                        return false;
                    }
                    if (currentFilters.queue && binding.destination !== currentFilters.queue) {
                        return false;
                    }
                    return true;
                });
                
                // Используем те же блоки, что и в диаграмме (передаем их из updateVisualization)
                // Если блоки не переданы, создаем их заново
                let filteredBlocks;
                if (window.currentFilteredBlocks) {
                    filteredBlocks = window.currentFilteredBlocks;
                } else {
                    const virtualHostBlocks = createVirtualHostBlocks(filteredExchanges, filteredQueues, filteredBindings);
                    filteredBlocks = filterVirtualHostBlocks(virtualHostBlocks);
                }
                
                // Подсчитываем количество VirtualHost из реально отображаемых блоков
                const virtualHostCount = filteredBlocks.length;
                
                
                // Считаем количество Exchange, которые реально отображаются в диаграмме
                let totalExchanges = 0;
                filteredBlocks.forEach(block => {
                    totalExchanges += block.exchanges.length;
                });
                
                // Считаем количество Queue, которые реально отображаются в диаграмме
                let totalQueues = 0;
                filteredBlocks.forEach(block => {
                    block.exchanges.forEach(exchange => {
                        exchange.routes.forEach(route => {
                            totalQueues += route.queues.length;
                        });
                    });
                });
                
                // Считаем количество Route, которые реально отображаются в диаграмме
                let totalRoutes = 0;
                filteredBlocks.forEach(block => {
                    block.exchanges.forEach(exchange => {
                        totalRoutes += exchange.routes.length;
                    });
                });
                
                // Подсчитываем Route multiple consumer из реально отображаемых данных
                const routeQueueCount = {};
                filteredBlocks.forEach(block => {
                    block.exchanges.forEach(exchange => {
                        exchange.routes.forEach(route => {
                            if (route.queues.length > 1) {
                                routeQueueCount[route.name] = route.queues.length;
                            }
                        });
                    });
                });
                const multiQueueRoutes = Object.keys(routeQueueCount).length;
                
                
                
                // Обновляем элементы статистики
                document.getElementById('virtualHostCount').textContent = virtualHostCount;
                document.getElementById('exchangeCount').textContent = totalExchanges;
                document.getElementById('queueCount').textContent = totalQueues;
                document.getElementById('routeCount').textContent = totalRoutes;
                document.getElementById('multiQueueRouteCount').textContent = multiQueueRoutes;
                
                // Центрируем диаграмму на экране
                centerDiagram();
                
            } catch (error) {
            }
        }
        
        // Функция центрирования диаграммы
        function centerDiagram() {
            try {
                if (!window.currentFilteredBlocks || window.currentFilteredBlocks.length === 0) {
                    return;
                }
                
                // Получаем размеры контейнера
                const container = document.getElementById('diagram-container');
                if (!container) {
                    return;
                }
                
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                if (containerWidth === 0 || containerHeight === 0) {
                    return;
                }
                
                // Рассчитываем общие размеры диаграммы
                let minX = Infinity;
                let maxX = -Infinity;
                let minY = Infinity;
                let maxY = -Infinity;
                
                window.currentFilteredBlocks.forEach(block => {
                    minX = Math.min(minX, block.x);
                    maxX = Math.max(maxX, block.x + block.width);
                    minY = Math.min(minY, block.y);
                    maxY = Math.max(maxY, block.y + block.height);
                });
                
                const diagramWidth = maxX - minX;
                const diagramHeight = maxY - minY;
                
                // Рассчитываем центр диаграммы
                const diagramCenterX = minX + diagramWidth / 2;
                const diagramCenterY = minY + diagramHeight / 2;
                
                // Рассчитываем центр контейнера
                const containerCenterX = containerWidth / 2;
                const containerCenterY = containerHeight / 2;
                
                // Рассчитываем смещение для центрирования
                const offsetX = containerCenterX - diagramCenterX;
                const offsetY = containerCenterY - diagramCenterY;
                
                console.log('Centering diagram:', {
                    containerWidth, containerHeight,
                    diagramCenterX, diagramCenterY,
                    containerCenterX, containerCenterY,
                    offsetX, offsetY
                });
                
                // Применяем трансформацию к группе g внутри SVG
                const svg = d3.select('#diagram-container svg');
                if (svg.empty()) {
                    return;
                }
                
                const g = svg.select('g');
                if (g.empty()) {
                    return;
                }
                
                g.transition()
                    .duration(500)
                    .attr('transform', `translate(${offsetX}, ${offsetY})`);
                    
            } catch (error) {
                // Ошибка при центрировании диаграммы - игнорируем
            }
        }
        
        // Настройка фильтров
        function setupFilters() {
            const exchanges = topology.exchanges || [];
            const queues = topology.queues || [];
            const bindings = topology.bindings || [];
            
            // Получаем элементы фильтров
            const virtualHostFilter = document.getElementById('virtualHostFilter');
            const exchangeFilter = document.getElementById('exchangeFilter');
            const routeFilter = document.getElementById('routeFilter');
            const queueFilter = document.getElementById('queueFilter');
            const virtualHostReset = document.getElementById('virtualHostReset');
            const exchangeReset = document.getElementById('exchangeReset');
            const routeReset = document.getElementById('routeReset');
            const queueReset = document.getElementById('queueReset');
            const virtualHostOpen = document.getElementById('virtualHostOpen');
            const exchangeOpen = document.getElementById('exchangeOpen');
            const routeOpen = document.getElementById('routeOpen');
            const queueOpen = document.getElementById('queueOpen');
            
            // Получаем элементы datalist
            const virtualHostList = document.getElementById('virtualHostList');
            const exchangeList = document.getElementById('exchangeList');
            const routeList = document.getElementById('routeList');
            const queueList = document.getElementById('queueList');
            
            // Сохраняем текущие значения фильтров
            const currentVirtualHost = virtualHostFilter.value;
            const currentExchange = exchangeFilter.value;
            const currentRoute = routeFilter.value;
            const currentQueue = queueFilter.value;
            
            // Очищаем кастомные выпадающие списки
            const virtualHostDropdown = document.getElementById('virtualHostDropdown');
            const exchangeDropdown = document.getElementById('exchangeDropdown');
            const routeDropdown = document.getElementById('routeDropdown');
            const queueDropdown = document.getElementById('queueDropdown');
            
            if (virtualHostDropdown) virtualHostDropdown.innerHTML = '';
            if (exchangeDropdown) exchangeDropdown.innerHTML = '';
            if (routeDropdown) routeDropdown.innerHTML = '';
            if (queueDropdown) queueDropdown.innerHTML = '';
            
            // Заполняем кастомные выпадающие списки
            const virtualHosts = new Set();
            exchanges.forEach(exchange => {
                virtualHosts.add(exchange.vhost || '/');
            });
            queues.forEach(queue => {
                virtualHosts.add(queue.vhost || '/');
            });
            
            // VirtualHost dropdown (уже получен выше)
            if (virtualHostDropdown) {
                virtualHostDropdown.innerHTML = '';
            virtualHosts.forEach(vhost => {
                const item = document.createElement('div');
                item.className = 'custom-dropdown-item';
                item.textContent = vhost;
                item.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    newVirtualHostFilter.value = vhost;
                    currentFilters.virtualHost = vhost;
                    virtualHostDropdown.style.display = 'none';
                    updateVisualization();
                };
                item.onmousedown = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                };
                virtualHostDropdown.appendChild(item);
            });
            }
            
            // Exchange dropdown (уже получен выше)
            if (exchangeDropdown) {
                exchangeDropdown.innerHTML = '';
            exchanges.forEach(exchange => {
                // Пропускаем Exchange с пустыми именами
                if (!exchange.name || exchange.name.trim() === '') {
                    return;
                }
                
                const item = document.createElement('div');
                item.className = 'custom-dropdown-item';
                item.textContent = exchange.name;
                item.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    newExchangeFilter.value = exchange.name;
                    currentFilters.exchange = exchange.name;
                    exchangeDropdown.style.display = 'none';
                    updateVisualization();
                };
                item.onmousedown = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                };
                exchangeDropdown.appendChild(item);
            });
            }
            
            // Queue dropdown (уже получен выше)
            if (queueDropdown) {
                queueDropdown.innerHTML = '';
            queues.forEach(queue => {
                // Пропускаем Queue с пустыми именами
                if (!queue.name || queue.name.trim() === '') {
                    return;
                }
                
                const item = document.createElement('div');
                item.className = 'custom-dropdown-item';
                item.textContent = queue.name;
                item.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    newQueueFilter.value = queue.name;
                    currentFilters.queue = queue.name;
                    queueDropdown.style.display = 'none';
                    updateVisualization();
                };
                item.onmousedown = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                };
                queueDropdown.appendChild(item);
            });
            }
            
            // Route dropdown (уже получен выше)
            if (routeDropdown) {
                routeDropdown.innerHTML = '';
            const routes = new Set();
            bindings.forEach(binding => {
                if (binding.routing_key && binding.routing_key.trim() !== '') {
                    routes.add(binding.routing_key);
                }
            });
            
            routes.forEach(route => {
                const item = document.createElement('div');
                item.className = 'custom-dropdown-item';
                item.textContent = route;
                item.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    newRouteFilter.value = route;
                    currentFilters.route = route;
                    routeDropdown.style.display = 'none';
                    updateVisualization();
                };
                item.onmousedown = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                };
                routeDropdown.appendChild(item);
            });
            }
            
            // Просто получаем элементы без замены
            const newVirtualHostFilter = document.getElementById('virtualHostFilter');
            const newExchangeFilter = document.getElementById('exchangeFilter');
            const newRouteFilter = document.getElementById('routeFilter');
            const newQueueFilter = document.getElementById('queueFilter');
            
            // Проверяем, что элементы существуют
            if (!newVirtualHostFilter || !newExchangeFilter || !newRouteFilter || !newQueueFilter) {
                return;
            }
            
            // Debounce функция для обновления после окончания ввода
            let updateTimeout;
            function debouncedUpdate() {
                clearTimeout(updateTimeout);
                updateTimeout = setTimeout(() => {
                    updateVisualization();
                }, 500); // Увеличиваем задержку до 500ms для более комфортного ввода
            }
            
            // Очищаем старые обработчики и добавляем новые
            newVirtualHostFilter.oninput = null;
            newVirtualHostFilter.onblur = null;
            newVirtualHostFilter.oninput = (e) => {
                currentFilters.virtualHost = e.target.value;
                showAutocomplete('virtualHost', e.target.value);
                debouncedUpdate();
            };
            newVirtualHostFilter.onblur = () => {
                clearTimeout(updateTimeout);
                // Добавляем небольшую задержку перед скрытием автодополнения
                setTimeout(() => {
                    hideAutocomplete('virtualHost');
                }, 150);
                updateVisualization();
            };
            newVirtualHostFilter.onkeydown = (e) => {
                if (e.key === 'Escape') {
                    hideAutocomplete('virtualHost');
                }
            };
            
            newExchangeFilter.oninput = null;
            newExchangeFilter.onblur = null;
            newExchangeFilter.oninput = (e) => {
                currentFilters.exchange = e.target.value;
                showAutocomplete('exchange', e.target.value);
                debouncedUpdate();
            };
            newExchangeFilter.onblur = () => {
                clearTimeout(updateTimeout);
                setTimeout(() => {
                    hideAutocomplete('exchange');
                }, 150);
                updateVisualization();
            };
            newExchangeFilter.onkeydown = (e) => {
                if (e.key === 'Escape') {
                    hideAutocomplete('exchange');
                }
            };
            
            newRouteFilter.oninput = null;
            newRouteFilter.onblur = null;
            newRouteFilter.oninput = (e) => {
                currentFilters.route = e.target.value;
                showAutocomplete('route', e.target.value);
                debouncedUpdate();
            };
            newRouteFilter.onblur = () => {
                clearTimeout(updateTimeout);
                setTimeout(() => {
                    hideAutocomplete('route');
                }, 150);
                updateVisualization();
            };
            newRouteFilter.onkeydown = (e) => {
                if (e.key === 'Escape') {
                    hideAutocomplete('route');
                }
            };
            
            newQueueFilter.oninput = null;
            newQueueFilter.onblur = null;
            newQueueFilter.oninput = (e) => {
                currentFilters.queue = e.target.value;
                showAutocomplete('queue', e.target.value);
                debouncedUpdate();
            };
            newQueueFilter.onblur = () => {
                clearTimeout(updateTimeout);
                setTimeout(() => {
                    hideAutocomplete('queue');
                }, 150);
                updateVisualization();
            };
            newQueueFilter.onkeydown = (e) => {
                if (e.key === 'Escape') {
                    hideAutocomplete('queue');
                }
            };
            
            // Кнопки сброса (очищаем и переназначаем обработчики)
            
            if (virtualHostReset) {
                virtualHostReset.onclick = null;
                virtualHostReset.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    newVirtualHostFilter.value = '';
                    currentFilters.virtualHost = '';
                    hideAutocomplete('virtualHost');
                    closeCustomDropdowns();
                    updateVisualization();
                };
            }
            
            if (exchangeReset) {
                exchangeReset.onclick = null;
                exchangeReset.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    newExchangeFilter.value = '';
                    currentFilters.exchange = '';
                    hideAutocomplete('exchange');
                    closeCustomDropdowns();
                    updateVisualization();
                };
            }
            
            if (routeReset) {
                routeReset.onclick = null;
                routeReset.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    newRouteFilter.value = '';
                    currentFilters.route = '';
                    hideAutocomplete('route');
                    closeCustomDropdowns();
                    updateVisualization();
                };
            }
            
            if (queueReset) {
                queueReset.onclick = null;
                queueReset.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    newQueueFilter.value = '';
                    currentFilters.queue = '';
                    hideAutocomplete('queue');
                    closeCustomDropdowns();
                    updateVisualization();
                };
            }

            // Функция для закрытия кастомных выпадающих списков
            function closeCustomDropdowns() {
                const allDropdowns = document.querySelectorAll('.custom-dropdown');
                allDropdowns.forEach(dropdown => {
                    dropdown.style.display = 'none';
                });
            }
            
            // Кнопки открытия списка (кастомный выпадающий список)
            function openCustomDropdown(inputEl, dropdownId) {
                try {
                    const dropdown = document.getElementById(dropdownId);
                    if (!dropdown) return;
                    
                    // Закрываем все другие выпадающие списки
                    const allDropdowns = document.querySelectorAll('.custom-dropdown');
                    allDropdowns.forEach(dd => {
                        if (dd.id !== dropdownId) {
                            dd.style.display = 'none';
                        }
                    });
                    
                    // Переключаем видимость текущего списка
                    if (dropdown.style.display === 'none' || dropdown.style.display === '') {
                        dropdown.style.display = 'block';
                        inputEl.focus();
                    } else {
                        dropdown.style.display = 'none';
                    }
                } catch (error) {
                }
            }
            
            // Закрытие выпадающих списков при клике вне их
            document.addEventListener('click', (event) => {
                if (!event.target.closest('.filter-group')) {
                    const allDropdowns = document.querySelectorAll('.custom-dropdown');
                    allDropdowns.forEach(dropdown => {
                        dropdown.style.display = 'none';
                    });
                    
                    // Также закрываем все автодополнения
                    const allAutocompletes = document.querySelectorAll('.autocomplete-suggestions');
                    allAutocompletes.forEach(autocomplete => {
                        autocomplete.style.display = 'none';
                    });
                }
            });
            
            
            if (virtualHostOpen) {
                virtualHostOpen.onclick = null;
                virtualHostOpen.onclick = () => openCustomDropdown(newVirtualHostFilter, 'virtualHostDropdown');
            }
            
            if (exchangeOpen) {
                exchangeOpen.onclick = null;
                exchangeOpen.onclick = () => openCustomDropdown(newExchangeFilter, 'exchangeDropdown');
            }
            
            if (routeOpen) {
                routeOpen.onclick = null;
                routeOpen.onclick = () => openCustomDropdown(newRouteFilter, 'routeDropdown');
            }
            
            if (queueOpen) {
                queueOpen.onclick = null;
                queueOpen.onclick = () => openCustomDropdown(newQueueFilter, 'queueDropdown');
            }
            
            // Восстанавливаем сохраненные значения
            if (currentVirtualHost) {
                newVirtualHostFilter.value = currentVirtualHost;
                currentFilters.virtualHost = currentVirtualHost;
            }
            if (currentExchange) {
                newExchangeFilter.value = currentExchange;
                currentFilters.exchange = currentExchange;
            }
            if (currentRoute) {
                newRouteFilter.value = currentRoute;
                currentFilters.route = currentRoute;
            }
            if (currentQueue) {
                newQueueFilter.value = currentQueue;
                currentFilters.queue = currentQueue;
            }
            
            // Функции автодополнения
            function showAutocomplete(filterType, value) {
                if (!value || value.trim() === '') {
                    hideAutocomplete(filterType);
                    return;
                }
                
                const autocompleteEl = document.getElementById(`${filterType}Autocomplete`);
                if (!autocompleteEl) return;
                
                // Получаем данные для автодополнения
                let suggestions = [];
                const searchValue = value.toLowerCase();
                
                switch(filterType) {
                    case 'virtualHost':
                        const virtualHosts = new Set();
                        exchanges.forEach(ex => virtualHosts.add(ex.vhost || '/'));
                        queues.forEach(q => virtualHosts.add(q.vhost || '/'));
                        suggestions = Array.from(virtualHosts).filter(vh => 
                            vh.toLowerCase().includes(searchValue)
                        );
                        break;
                    case 'exchange':
                        suggestions = exchanges
                            .filter(ex => ex.name && ex.name.trim() !== '' && ex.name.toLowerCase().includes(searchValue))
                            .map(ex => ex.name);
                        break;
                    case 'route':
                        const routes = new Set();
                        bindings.forEach(binding => {
                            if (binding.routing_key && binding.routing_key.trim() !== '' && binding.routing_key.toLowerCase().includes(searchValue)) {
                                routes.add(binding.routing_key);
                            }
                        });
                        suggestions = Array.from(routes);
                        break;
                    case 'queue':
                        suggestions = queues
                            .filter(q => q.name && q.name.trim() !== '' && q.name.toLowerCase().includes(searchValue))
                            .map(q => q.name);
                        break;
                }
                
                // Ограничиваем количество предложений
                suggestions = suggestions.slice(0, 10);
                
                if (suggestions.length === 0) {
                    hideAutocomplete(filterType);
                    return;
                }
                
                // Очищаем предыдущие предложения
                autocompleteEl.innerHTML = '';
                
                // Добавляем новые предложения
                suggestions.forEach(suggestion => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-suggestion';
                    item.textContent = suggestion;
                    item.onclick = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const inputEl = document.getElementById(`${filterType}Filter`);
                        if (inputEl) {
                            inputEl.value = suggestion;
                            currentFilters[filterType] = suggestion;
                            hideAutocomplete(filterType);
                            updateVisualization();
                        }
                    };
                    item.onmousedown = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    };
                    autocompleteEl.appendChild(item);
                });
                
                autocompleteEl.style.display = 'block';
            }
            
            function hideAutocomplete(filterType) {
                const autocompleteEl = document.getElementById(`${filterType}Autocomplete`);
                if (autocompleteEl) {
                    autocompleteEl.style.display = 'none';
                }
            }
        }
        
        // Обработчики кнопок
        document.getElementById('refreshBtn').addEventListener('click', () => {
            centerDiagram();
        });
        
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            if (svg && zoom) {
                svg.transition().call(zoom.scaleBy, 1.5);
            }
        });
        
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            if (svg && zoom) {
                svg.transition().call(zoom.scaleBy, 1 / 1.5);
            }
        });
        
        // Инициализация при загрузке страницы
        window.addEventListener('load', () => {
            if (typeof d3 !== 'undefined') {
                initVisualization();
            } else {
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка загрузки D3.js</h2><p>Библиотека D3.js не загружена</p></div>';
            }
        });
        
        // Обработчик изменения размера окна для центрирования диаграммы
        window.addEventListener('resize', function() {
            if (window.currentFilteredBlocks && window.currentFilteredBlocks.length > 0) {
                centerDiagram();
            }
        });
    </script>
</body>
</html>
