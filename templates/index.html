<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RabbitMQ ERD Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="/static/css/style.css">
    <style>
        .filters {
            display: flex;
            gap: 20px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .filter-group label {
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }
        
        .filter-group select {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .exchange-block {
            cursor: pointer;
        }
        
        .route {
            cursor: pointer;
        }
        
        .queue {
            cursor: pointer;
        }
        
        .exchange-block:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 3 !important;
        }
        
        .route:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 2 !important;
        }
        
        .queue:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 2 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>RabbitMQ ERD Visualizer</h1>
            <div class="controls">
                <button id="refreshBtn" class="btn">Обновить</button>
                <button id="zoomInBtn" class="btn">+</button>
                <button id="zoomOutBtn" class="btn">-</button>
            </div>
        </header>
        
        <div class="info-panel">
            <div class="stats">
                <div class="stat-item">
                    <span class="label">Обмены:</span>
                    <span class="value" id="exchangeCount">{{ topology.exchanges|length }}</span>
                </div>
                <div class="stat-item">
                    <span class="label">Очереди:</span>
                    <span class="value" id="queueCount">{{ topology.queues|length }}</span>
                </div>
                <div class="stat-item">
                    <span class="label">Связи:</span>
                    <span class="value" id="connectionCount">{{ topology.connections|length }}</span>
                </div>
            </div>
            <div class="filters">
                <div class="filter-group">
                    <label>Фильтр по VirtualHost:</label>
                    <select id="virtualHostFilter">
                        <option value="">Все VirtualHost</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Фильтр по Exchanges:</label>
                    <select id="exchangeFilter">
                        <option value="">Все Exchanges</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Фильтр по RoutingKey:</label>
                    <select id="routeFilter">
                        <option value="">Все RoutingKey</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Фильтр по очередям:</label>
                    <select id="queueFilter">
                        <option value="">Все очереди</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="visualization-container">
            <svg id="diagram" width="100%" height="600"></svg>
        </div>
        
        <div class="details-panel" id="detailsPanel" style="display: none;">
            <h3>Детали</h3>
            <div id="detailsContent"></div>
        </div>
    </div>
    
    <script>
        // Данные топологии
        const topology = {{ topology | tojson }};
        
        // Конфигурация
        const config = {
            virtualHostWidth: 400,
            virtualHostHeight: 400,
            blockWidth: 300,
            blockHeight: 300,
            routeHeight: 35,
            queueHeight: 25,
            colors: {
                virtualHost: '#9C27B0',
                exchange: 'transparent',
                route: '#FF9800',
                queue: '#2196F3',
                connection: '#666'
            }
        };
        
        // Глобальные переменные
        let svg, g, zoom;
        let currentFilters = {
            virtualHost: '',
            exchange: '',
            route: '',
            queue: ''
        };
        
        // Инициализация визуализации
        function initVisualization() {
            try {
                svg = d3.select('#diagram');
                g = svg.append('g');
                
                zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                
                updateVisualization();
                setupFilters();
            } catch (error) {
                console.error('Ошибка инициализации:', error);
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка инициализации</h2><p>' + error.message + '</p>';
            }
        }
        
        // Обновление визуализации
        function updateVisualization() {
            try {
                if (!topology) {
                    console.error('Данные топологии не загружены');
                    return;
                }
                
                g.selectAll('*').remove();
                
                const exchanges = topology.exchanges || [];
                const queues = topology.queues || [];
                const bindings = topology.bindings || [];
                
                if (exchanges.length === 0) {
                    g.append('text')
                        .attr('x', '50%')
                        .attr('y', '50%')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '0.35em')
                        .attr('font-size', '18px')
                        .attr('fill', '#666')
                        .text('Нет данных для отображения');
                    return;
                }
                
                // Создаем структуру данных
                const virtualHostBlocks = createVirtualHostBlocks(exchanges, queues, bindings);
                
                // Фильтруем данные
                const filteredBlocks = filterVirtualHostBlocks(virtualHostBlocks);
                
                // Рисуем блоки
                drawVirtualHostBlocks(filteredBlocks);
                
            } catch (error) {
                console.error('Ошибка обновления визуализации:', error);
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка визуализации</h2><p>' + error.message + '</p></div>';
            }
        }
        
        // Создание блоков VirtualHost
        function createVirtualHostBlocks(exchanges, queues, bindings) {
            // Группируем по VirtualHost
            const virtualHosts = {};
            
            // Добавляем exchanges в VirtualHost
            exchanges.forEach(exchange => {
                const vhost = exchange.vhost || '/';
                if (!virtualHosts[vhost]) {
                    virtualHosts[vhost] = {
                        name: vhost,
                        exchanges: []
                    };
                }
                virtualHosts[vhost].exchanges.push(exchange);
            });
            
            // Добавляем queues в VirtualHost
            queues.forEach(queue => {
                const vhost = queue.vhost || '/';
                if (!virtualHosts[vhost]) {
                    virtualHosts[vhost] = {
                        name: vhost,
                        exchanges: []
                    };
                }
            });
            
            // Создаем структуру для каждого VirtualHost
            return Object.values(virtualHosts).map((vhost, index) => {
                const vhostExchanges = vhost.exchanges.map(exchange => {
                    // Находим связанные очереди через bindings
                    const relatedBindings = bindings.filter(binding => 
                        binding.source === exchange.name || binding.destination === exchange.name
                    );
                    
                    // Группируем по роутам (routing_key)
                    const routes = {};
                    relatedBindings.forEach(binding => {
                        const routeKey = binding.routing_key || 'default';
                        if (!routes[routeKey]) {
                            routes[routeKey] = [];
                        }
                        routes[routeKey].push(binding);
                    });
                    
                    // Создаем структуру роутов
                    const routeList = Object.keys(routes).map(routeKey => {
                        const routeBindings = routes[routeKey];
                        const routeQueues = routeBindings.map(binding => {
                            const queueName = binding.destination === exchange.name ? 
                                binding.source : binding.destination;
                            return queues.find(q => q.name === queueName);
                        }).filter(q => q);
                        
                        return {
                            name: routeKey,
                            queues: routeQueues,
                            bindings: routeBindings
                        };
                    });
                    
                    return {
                        exchange: exchange,
                        routes: routeList
                    };
                });
                
                return {
                    virtualHost: vhost,
                    exchanges: vhostExchanges,
                    x: 50 + index * 450,
                    y: 50
                };
            });
        }
        
        // Фильтрация блоков VirtualHost
        function filterVirtualHostBlocks(blocks) {
            return blocks.filter(block => {
                if (currentFilters.virtualHost && block.virtualHost.name !== currentFilters.virtualHost) {
                    return false;
                }
                
                if (currentFilters.exchange) {
                    const hasMatchingExchange = block.exchanges.some(exchange => 
                        exchange.exchange.name === currentFilters.exchange
                    );
                    if (!hasMatchingExchange) return false;
                }
                
                if (currentFilters.route) {
                    const hasMatchingRoute = block.exchanges.some(exchange =>
                        exchange.routes.some(route => route.name === currentFilters.route)
                    );
                    if (!hasMatchingRoute) return false;
                }
                
                if (currentFilters.queue) {
                    const hasMatchingQueue = block.exchanges.some(exchange =>
                        exchange.routes.some(route =>
                            route.queues.some(queue => queue.name === currentFilters.queue)
                        )
                    );
                    if (!hasMatchingQueue) return false;
                }
                
                return true;
            });
        }
        
        // Рисование блоков VirtualHost
        function drawVirtualHostBlocks(blocks) {
            try {
                const virtualHostGroups = g.append('g')
                    .attr('class', 'virtualhost-blocks')
                    .selectAll('g')
                    .data(blocks)
                    .enter().append('g')
                    .attr('class', 'virtualhost-block')
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);
                
                // Рисуем основной блок VirtualHost
                virtualHostGroups.append('rect')
                    .attr('width', config.virtualHostWidth)
                    .attr('height', config.virtualHostHeight)
                    .attr('rx', 15)
                    .attr('fill', config.colors.virtualHost)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 3);
                
                // Заголовок VirtualHost
                virtualHostGroups.append('text')
                    .attr('x', config.virtualHostWidth / 2)
                    .attr('y', 30)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'white')
                    .attr('font-weight', 'bold')
                    .attr('font-size', '16px')
                    .text(d => `VirtualHost: ${d.virtualHost.name}`);
                
                // Рисуем exchanges для каждого VirtualHost
                blocks.forEach((block, blockIndex) => {
                    let exchangeY = 60;
                    
                    block.exchanges.forEach((exchangeData, exchangeIndex) => {
                        const exchangeGroup = virtualHostGroups.filter(d => d === block)
                            .append('g')
                            .attr('class', 'exchange')
                            .attr('transform', `translate(20, ${exchangeY})`);
                        
                        // Exchange
                        exchangeGroup.append('rect')
                            .attr('width', config.virtualHostWidth - 40)
                            .attr('height', config.blockHeight)
                            .attr('rx', 10)
                            .attr('fill', config.colors.exchange)
                            .attr('stroke', '#333')
                            .attr('stroke-width', 2);
                        
                        exchangeGroup.append('text')
                            .attr('x', 10)
                            .attr('y', 25)
                            .attr('fill', '#333')
                            .attr('font-weight', 'bold')
                            .attr('font-size', '14px')
                            .text(`Exchange: ${exchangeData.exchange.name}`);
                        
                        // Рисуем роуты для каждого exchange
                        let routeY = 50;
                        exchangeData.routes.forEach((route, routeIndex) => {
                            const routeGroup = exchangeGroup.append('g')
                                .attr('class', 'route')
                                .attr('transform', `translate(10, ${routeY})`);
                            
                            // Роут
                            routeGroup.append('rect')
                                .attr('width', config.virtualHostWidth - 60)
                                .attr('height', config.routeHeight)
                                .attr('rx', 5)
                                .attr('fill', config.colors.route)
                                .attr('stroke', '#333')
                                .attr('stroke-width', 1);
                            
                            routeGroup.append('text')
                                .attr('x', 10)
                                .attr('y', 20)
                                .attr('fill', 'white')
                                .attr('font-size', '12px')
                                .text(`RoutingKey: ${route.name}`);
                            
                            // Очереди
                            let queueY = 40;
                            route.queues.forEach((queue, queueIndex) => {
                                const queueGroup = routeGroup.append('g')
                                    .attr('class', 'queue')
                                    .attr('transform', `translate(20, ${queueY})`);
                                
                                queueGroup.append('rect')
                                    .attr('width', config.virtualHostWidth - 80)
                                    .attr('height', config.queueHeight)
                                    .attr('rx', 3)
                                    .attr('fill', config.colors.queue)
                                    .attr('stroke', '#333')
                                    .attr('stroke-width', 1);
                                
                                queueGroup.append('text')
                                    .attr('x', 10)
                                    .attr('y', 16)
                                    .attr('fill', 'white')
                                    .attr('font-size', '10px')
                                    .text(queue.name);
                                
                                queueY += 30;
                            });
                            
                            // Переходим к следующему роуту
                            routeY += 40 + (route.queues.length * 30);
                        });
                        
                        // Переходим к следующему exchange
                        exchangeY += 50 + (exchangeData.routes.length * 40);
                    });
                });
            } catch (error) {
                console.error('Ошибка рисования блоков:', error);
                g.append('text')
                    .attr('x', '50%')
                    .attr('y', '50%')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .attr('font-size', '16px')
                    .attr('fill', '#ff0000')
                    .text('Ошибка отображения блоков');
            }
        }
        
        // Настройка фильтров
        function setupFilters() {
            const exchanges = topology.exchanges || [];
            const queues = topology.queues || [];
            const bindings = topology.bindings || [];
            
            // Заполняем фильтр VirtualHost
            const virtualHostFilter = document.getElementById('virtualHostFilter');
            const virtualHosts = new Set();
            exchanges.forEach(exchange => {
                virtualHosts.add(exchange.vhost || '/');
            });
            queues.forEach(queue => {
                virtualHosts.add(queue.vhost || '/');
            });
            virtualHosts.forEach(vhost => {
                const option = document.createElement('option');
                option.value = vhost;
                option.textContent = vhost;
                virtualHostFilter.appendChild(option);
            });
            
            // Заполняем фильтр обменов
            const exchangeFilter = document.getElementById('exchangeFilter');
            exchanges.forEach(exchange => {
                const option = document.createElement('option');
                option.value = exchange.name;
                option.textContent = exchange.name;
                exchangeFilter.appendChild(option);
            });
            
            // Заполняем фильтр очередей
            const queueFilter = document.getElementById('queueFilter');
            queues.forEach(queue => {
                const option = document.createElement('option');
                option.value = queue.name;
                option.textContent = queue.name;
                queueFilter.appendChild(option);
            });
            
            // Заполняем фильтр роутов
            const routeFilter = document.getElementById('routeFilter');
            const routes = new Set();
            bindings.forEach(binding => {
                if (binding.routing_key) {
                    routes.add(binding.routing_key);
                }
            });
            routes.forEach(route => {
                const option = document.createElement('option');
                option.value = route;
                option.textContent = route;
                routeFilter.appendChild(option);
            });
            
            // Обработчики фильтров
            virtualHostFilter.addEventListener('change', (e) => {
                currentFilters.virtualHost = e.target.value;
                updateVisualization();
            });
            
            exchangeFilter.addEventListener('change', (e) => {
                currentFilters.exchange = e.target.value;
                updateVisualization();
            });
            
            routeFilter.addEventListener('change', (e) => {
                currentFilters.route = e.target.value;
                updateVisualization();
            });
            
            queueFilter.addEventListener('change', (e) => {
                currentFilters.queue = e.target.value;
                updateVisualization();
            });
        }
        
        // Обработчики кнопок
        document.getElementById('refreshBtn').addEventListener('click', () => {
            updateVisualization();
        });
        
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            if (svg && zoom) {
                svg.transition().call(zoom.scaleBy, 1.5);
            }
        });
        
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            if (svg && zoom) {
                svg.transition().call(zoom.scaleBy, 1 / 1.5);
            }
        });
        
        // Инициализация при загрузке страницы
        window.addEventListener('load', () => {
            if (typeof d3 !== 'undefined') {
                initVisualization();
            } else {
                console.error('D3.js не загружен');
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка загрузки D3.js</h2><p>Библиотека D3.js не загружена</p></div>';
            }
        });
    </script>
</body>
</html>
