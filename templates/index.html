<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RabbitMQ ERD Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="/static/css/style.css">
    <style>
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            background: #f7f7f7;
            border-bottom: 1px solid #e5e5e5;
        }

        header h1 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }

        header .controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        header .controls .btn {
            padding: 4px 8px;
            font-size: 12px;
            line-height: 1.2;
        }
        /* Видимость плейсхолдеров и удобство ввода */
        .filters input[type="text"] {
            height: 32px;
            line-height: 20px;
            padding: 6px 10px;
            font-size: 14px;
            box-sizing: border-box;
            width: 220px;
        }

        .filter-group {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .filter-input-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .filter-reset, .filter-open {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border: 1px solid #ccc;
            background: #fff;
            color: #666;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
        }

        .filter-reset:hover, .filter-open:hover {
            background: #f0f0f0;
        }
        .stats-container {
            margin: 10px 0;
            background: #f0f8ff;
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
        }
        
        .stats-header {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 10px;
            background: #e0f0ff;
            border-bottom: 1px solid #ddd;
        }
        
        .stats-header:hover {
            background: #d0e0ff;
        }
        
        .stats-toggle {
            font-size: 16px;
            transition: transform 0.3s ease;
        }
        
        .stats-toggle.collapsed {
            transform: rotate(-90deg);
        }
        
        .stats {
            display: flex;
            gap: 20px;
            padding: 15px;
            flex-wrap: wrap;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .stats.collapsed {
            max-height: 0;
            padding: 0 15px;
        }
        
        .filters-container {
            margin: 10px 0;
            background: #f5f5f5;
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
        }
        
        .filters-header {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 10px;
            background: #e5e5e5;
            border-bottom: 1px solid #ddd;
        }
        
        .filters-header:hover {
            background: #d5d5d5;
        }
        
        .filters-toggle {
            font-size: 16px;
            transition: transform 0.3s ease;
        }
        
        .filters-toggle.collapsed {
            transform: rotate(-90deg);
        }
        
        .filters {
            display: flex;
            gap: 20px;
            padding: 15px;
            margin: 10px 0;
            flex-wrap: wrap;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .filters.collapsed {
            max-height: 0;
            margin: 0;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .filter-group label {
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }
        
        .filter-group select {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .exchange-block {
            cursor: pointer;
        }
        
        .route {
            cursor: pointer;
        }
        
        .queue {
            cursor: pointer;
        }
        
        .exchange-block:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 3 !important;
        }
        
        .route:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 2 !important;
        }
        
        .queue:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 2 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>RabbitMQ Visualizer</h1>
            <div class="controls">
                <button id="refreshBtn" class="btn">Обновить</button>
                <button id="zoomInBtn" class="btn">+</button>
                <button id="zoomOutBtn" class="btn">-</button>
            </div>
        </header>
        
        <div class="stats-container">
            <div class="stats-header" onclick="toggleStats()">
                <span class="stats-toggle" id="statsToggle">▼</span>
                <span>Статистика</span>
            </div>
            <div class="stats" id="stats">
                <div class="stat-item">
                    <span class="label">VirtualHost:</span>
                    <span class="value" id="virtualHostCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="label">Exchange:</span>
                    <span class="value" id="exchangeCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="label">Queue:</span>
                    <span class="value" id="queueCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="label">Route:</span>
                    <span class="value" id="routeCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="label">Route multiple consumer:</span>
                    <span class="value" id="multiQueueRouteCount">0</span>
                </div>
            </div>
        </div>
            <div class="filters-container">
                <div class="filters-header" onclick="toggleFilters()">
                    <span class="filters-toggle" id="filtersToggle">▼</span>
                    <span>Фильтры</span>
                </div>
                <div class="filters" id="filters">
                    <div class="filter-group">
                        <label for="virtualHostFilter">VirtualHost:</label>
                        <div class="filter-input-row">
                            <input type="text" id="virtualHostFilter" placeholder="Введите VirtualHost или выберите из списка" list="virtualHostList">
                            <button type="button" id="virtualHostOpen" class="filter-open" title="Открыть список" aria-label="Открыть список">▾</button>
                            <button type="button" id="virtualHostReset" class="filter-reset" title="Сбросить VirtualHost" aria-label="Сбросить VirtualHost">×</button>
                        </div>
                        <datalist id="virtualHostList"></datalist>
                    </div>
                    <div class="filter-group">
                        <label for="exchangeFilter">Exchange:</label>
                        <div class="filter-input-row">
                            <input type="text" id="exchangeFilter" placeholder="Введите Exchange или выберите из списка" list="exchangeList">
                            <button type="button" id="exchangeOpen" class="filter-open" title="Открыть список" aria-label="Открыть список">▾</button>
                            <button type="button" id="exchangeReset" class="filter-reset" title="Сбросить Exchange" aria-label="Сбросить Exchange">×</button>
                        </div>
                        <datalist id="exchangeList"></datalist>
                    </div>
                    <div class="filter-group">
                        <label for="routeFilter">RoutingKey:</label>
                        <div class="filter-input-row">
                            <input type="text" id="routeFilter" placeholder="Введите RoutingKey или выберите из списка" list="routeList">
                            <button type="button" id="routeOpen" class="filter-open" title="Открыть список" aria-label="Открыть список">▾</button>
                            <button type="button" id="routeReset" class="filter-reset" title="Сбросить RoutingKey" aria-label="Сбросить RoutingKey">×</button>
                        </div>
                        <datalist id="routeList"></datalist>
                    </div>
                    <div class="filter-group">
                        <label for="queueFilter">Queue:</label>
                        <div class="filter-input-row">
                            <input type="text" id="queueFilter" placeholder="Введите Queue или выберите из списка" list="queueList">
                            <button type="button" id="queueOpen" class="filter-open" title="Открыть список" aria-label="Открыть список">▾</button>
                            <button type="button" id="queueReset" class="filter-reset" title="Сбросить Queue" aria-label="Сбросить Queue">×</button>
                        </div>
                        <datalist id="queueList"></datalist>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="visualization-container">
            <svg id="diagram" width="100%" height="600"></svg>
        </div>
        
        <div class="details-panel" id="detailsPanel" style="display: none;">
            <h3>Детали</h3>
            <div id="detailsContent"></div>
        </div>
    </div>
    
    <!-- Скрытые данные топологии -->
    <script type="application/json" id="topologyData">{{ topology | tojson }}</script>
    
    <script>
        // Данные топологии
        const topologyData = document.getElementById('topologyData').textContent;
        const topology = JSON.parse(topologyData);
        
        // Конфигурация
        const config = {
            virtualHostWidth: 400,
            virtualHostHeight: 400,
            blockWidth: 300,
            blockHeight: 300,
            routeHeight: 35,
            queueHeight: 25,
            colors: {
                virtualHost: 'transparent',
                exchange: 'transparent',
                route: '#FF9800',
                queue: '#2196F3',
                connection: '#666'
            }
        };
        
        // Глобальные переменные
        let svg, g, zoom;
        let currentFilters = {
            virtualHost: '',
            exchange: '',
            route: '',
            queue: ''
        };
        
        // Инициализация визуализации
        function initVisualization() {
            try {
                svg = d3.select('#diagram');
                g = svg.append('g');
                
                zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                
                updateVisualization();
            } catch (error) {
                console.error('Ошибка инициализации:', error);
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка инициализации</h2><p>' + error.message + '</p>';
            }
        }
        
        // Обновление визуализации
        function updateVisualization() {
            try {
                if (!topology) {
                    console.error('Данные топологии не загружены');
                    return;
                }
                
                g.selectAll('*').remove();
                
                const exchanges = topology.exchanges || [];
                const queues = topology.queues || [];
                const bindings = topology.bindings || [];
                
                
                if (exchanges.length === 0 && queues.length === 0) {
                    g.append('text')
                        .attr('x', '50%')
                        .attr('y', '50%')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '0.35em')
                        .attr('font-size', '18px')
                        .attr('fill', '#666')
                        .text('Нет данных для отображения');
                    return;
                }
                
                // Создаем структуру данных
                const virtualHostBlocks = createVirtualHostBlocks(exchanges, queues, bindings);
                
                // Фильтруем данные
                const filteredBlocks = filterVirtualHostBlocks(virtualHostBlocks);
                
                // Рисуем блоки
                drawVirtualHostBlocks(filteredBlocks);
                
                // Настраиваем фильтры после обновления данных
                setupFilters();
                
                // Обновляем статистику
                updateStats();
                
            } catch (error) {
                console.error('Ошибка обновления визуализации:', error);
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка визуализации</h2><p>' + error.message + '</p></div>';
            }
        }
        
        // Создание блоков VirtualHost
        function createVirtualHostBlocks(exchanges, queues, bindings) {
            // Группируем по VirtualHost
            const virtualHosts = {};
            
            // Добавляем exchanges в VirtualHost
            exchanges.forEach(exchange => {
                const vhost = exchange.vhost || '/';
                if (!virtualHosts[vhost]) {
                    virtualHosts[vhost] = {
                        name: vhost,
                        exchanges: []
                    };
                }
                virtualHosts[vhost].exchanges.push(exchange);
            });
            
            // Добавляем queues в VirtualHost
            queues.forEach(queue => {
                const vhost = queue.vhost || '/';
                if (!virtualHosts[vhost]) {
                    virtualHosts[vhost] = {
                        name: vhost,
                        exchanges: []
                    };
                }
            });
            
            // Создаем структуру для каждого VirtualHost
            return Object.values(virtualHosts).map((vhost, index) => {
                const vhostExchanges = vhost.exchanges.map(exchange => {
                    // Находим связанные очереди через bindings
                    const relatedBindings = bindings.filter(binding => 
                        binding.source === exchange.name || binding.destination === exchange.name
                    );
                    
                    // Группируем по роутам (routing_key)
                    const routes = {};
                    relatedBindings.forEach(binding => {
                        const routeKey = binding.routing_key || 'default';
                        if (!routes[routeKey]) {
                            routes[routeKey] = [];
                        }
                        routes[routeKey].push(binding);
                    });
                    
                    // Создаем структуру роутов
                    const routeList = Object.keys(routes).map(routeKey => {
                        const routeBindings = routes[routeKey];
                        const routeQueues = routeBindings.map(binding => {
                            const queueName = binding.destination === exchange.name ? 
                                binding.source : binding.destination;
                            return queues.find(q => q.name === queueName);
                        }).filter(q => q);
                        
                        return {
                            name: routeKey,
                            queues: routeQueues,
                            bindings: routeBindings,
                            queueCount: routeQueues.length
                        };
                    });
                    
                    // Для каждого роута устанавливаем максимальное количество очередей в этом роуте
                    routeList.forEach(route => {
                        route.maxQueuesInRoute = route.queueCount; // Максимум очередей в этом конкретном роуте
                    });
                    
                    return {
                        exchange: exchange,
                        routes: routeList
                    };
                });
                
                return {
                    virtualHost: vhost,
                    exchanges: vhostExchanges,
                    x: 0, // Будет пересчитано в drawVirtualHostBlocks
                    y: 50
                };
            });
        }
        
        // Фильтрация блоков VirtualHost
        function filterVirtualHostBlocks(blocks) {
            console.log('Фильтрация с параметрами:', currentFilters);
            console.log('Всего блоков до фильтрации:', blocks.length);
            
            const filtered = blocks.map(block => {
                // Фильтруем VirtualHost по имени
                if (currentFilters.virtualHost && block.virtualHost.name !== currentFilters.virtualHost) {
                    console.log('Блок отфильтрован по VirtualHost:', block.virtualHost.name, '!=', currentFilters.virtualHost);
                    return null;
                }
                
                // Фильтруем exchanges внутри блока
                const filteredExchanges = block.exchanges.filter(exchange => {
                    // Фильтр по exchange
                    if (currentFilters.exchange && exchange.exchange.name !== currentFilters.exchange) {
                        return false;
                    }
                    
                    // Фильтруем routes внутри exchange
                    const filteredRoutes = exchange.routes.filter(route => {
                        // Фильтр по route
                        if (currentFilters.route && route.name !== currentFilters.route) {
                            return false;
                        }
                        
                        // Фильтруем queues внутри route
                        const filteredQueues = route.queues.filter(queue => {
                            // Фильтр по queue
                            if (currentFilters.queue && queue.name !== currentFilters.queue) {
                                return false;
                            }
                            return true;
                        });
                        
                        // Обновляем queues в route
                        route.queues = filteredQueues;
                        
                        // Пересчитываем количество очередей в роуте после фильтрации
                        route.queueCount = filteredQueues.length;
                        route.maxQueuesInRoute = filteredQueues.length;
                        
                        // Возвращаем route только если в нем есть очереди после фильтрации
                        return filteredQueues.length > 0;
                    });
                    
                    // Обновляем routes в exchange
                    exchange.routes = filteredRoutes;
                    
                    // Возвращаем exchange только если в нем есть routes после фильтрации
                    return filteredRoutes.length > 0;
                });
                
                // Обновляем exchanges в блоке
                block.exchanges = filteredExchanges;
                
                // Возвращаем блок только если в нем есть exchanges после фильтрации
                return filteredExchanges.length > 0 ? block : null;
            }).filter(block => block !== null);
            
            console.log('Блоков после фильтрации:', filtered.length);
            return filtered;
        }
        
        // Рисование блоков VirtualHost
        function drawVirtualHostBlocks(blocks) {
            try {
                // Сначала рассчитываем размеры всех блоков и их позиции
                let currentX = 50; // Начальная позиция
                
                blocks.forEach((block, blockIndex) => {
                    // Рассчитываем высоту на основе содержимого (максимальная высота среди всех exchanges)
                    let maxHeight = 80; // Заголовок + отступы
                    let totalWidth = 40; // Отступы
                    
                    block.exchanges.forEach(exchangeData => {
                        // Рассчитываем размеры exchange на основе содержимого
                        let exchangeWidth = 200; // Минимальная ширина
                        let exchangeHeight = 50; // Высота заголовка
                        
                        // Учитываем длину названия Exchange
                        const exchangeNameWidth = Math.max(200, exchangeData.exchange.name.length * 8 + 100);
                        exchangeWidth = Math.max(exchangeWidth, exchangeNameWidth);
                        
                        exchangeData.routes.forEach(route => {
                            const routeWidth = Math.max(150, route.name.length * 8 + 100);
                            exchangeWidth = Math.max(exchangeWidth, routeWidth + 20);
                            
                            exchangeHeight += 40; // Высота route
                            
                            route.queues.forEach(queue => {
                                const queueWidth = Math.max(100, queue.name.length * 6 + 80);
                                exchangeWidth = Math.max(exchangeWidth, queueWidth + 40);
                                
                                exchangeHeight += 30; // Высота очереди
                            });
                        });
                        
                        // Обновляем общие размеры VirtualHost
                        maxHeight = Math.max(maxHeight, exchangeHeight + 80);
                        totalWidth += exchangeWidth + 20; // Ширина exchange + отступ
                    });
                    
                    // Устанавливаем позицию и размеры блока
                    block.x = currentX;
                    block.y = 50;
                    block.width = totalWidth;
                    block.height = maxHeight;
                    
                    // Переходим к следующему блоку
                    currentX += totalWidth + 50; // Ширина блока + отступ
                });
                
                // Теперь создаем SVG элементы
                const virtualHostGroups = g.append('g')
                    .attr('class', 'virtualhost-blocks')
                    .selectAll('g')
                    .data(blocks)
                    .enter().append('g')
                    .attr('class', 'virtualhost-block')
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);
                
                // Рисуем блоки VirtualHost
                blocks.forEach((block, blockIndex) => {
                    const currentVirtualHostGroup = virtualHostGroups.filter(d => d === block);
                    
                    // Рисуем основной блок VirtualHost с рассчитанными размерами
                    currentVirtualHostGroup.append('rect')
                        .attr('width', block.width)
                        .attr('height', block.height)
                        .attr('rx', 15)
                        .attr('fill', config.colors.virtualHost)
                        .attr('stroke', '#333')
                        .attr('stroke-width', 3);
                    
                    // Заголовок VirtualHost
                    currentVirtualHostGroup.append('text')
                        .attr('x', block.width / 2)
                        .attr('y', 30)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#333')
                        .attr('font-weight', 'bold')
                        .attr('font-size', '16px')
                        .text(`VirtualHost: ${block.virtualHost.name}`);
                });
                
                // Рисуем содержимое для каждого VirtualHost отдельно
                blocks.forEach((block, blockIndex) => {
                    const currentVirtualHostGroup = virtualHostGroups.filter(d => d === block);
                    let exchangeX = 20;
                    
                    block.exchanges.forEach((exchangeData, exchangeIndex) => {
                        // Используем уже рассчитанные размеры из первого прохода
                        let exchangeWidth = 200; // Минимальная ширина
                        let exchangeHeight = 50; // Высота заголовка
                        
                        // Учитываем длину названия Exchange
                        const exchangeNameWidth = Math.max(200, exchangeData.exchange.name.length * 8 + 100);
                        exchangeWidth = Math.max(exchangeWidth, exchangeNameWidth);
                        
                        exchangeData.routes.forEach(route => {
                            const routeWidth = Math.max(150, route.name.length * 8 + 100);
                            exchangeWidth = Math.max(exchangeWidth, routeWidth + 20);
                            
                            exchangeHeight += 40; // Высота route
                            
                            route.queues.forEach(queue => {
                                const queueWidth = Math.max(100, queue.name.length * 6 + 80);
                                exchangeWidth = Math.max(exchangeWidth, queueWidth + 40);
                                
                                exchangeHeight += 30; // Высота очереди
                            });
                        });
                        
                        const exchangeGroup = currentVirtualHostGroup.append('g')
                            .attr('class', 'exchange')
                            .attr('transform', `translate(${exchangeX}, 60)`);
                        
                        // Exchange с рассчитанными размерами
                        exchangeGroup.append('rect')
                            .attr('width', exchangeWidth)
                            .attr('height', exchangeHeight)
                            .attr('rx', 10)
                            .attr('fill', config.colors.exchange)
                            .attr('stroke', '#333')
                            .attr('stroke-width', 2);
                        
                        exchangeGroup.append('text')
                            .attr('x', 10)
                            .attr('y', 25)
                            .attr('fill', '#333')
                            .attr('font-weight', 'bold')
                            .attr('font-size', '14px')
                            .text(`Exchange: ${exchangeData.exchange.name}`);
                        
                        // Рисуем роуты для каждого exchange
                        let routeY = 50;
                        exchangeData.routes.forEach((route, routeIndex) => {
                            const routeGroup = exchangeGroup.append('g')
                                .attr('class', 'route')
                                .attr('transform', `translate(10, ${routeY})`);
                            
                            // Роут
                            routeGroup.append('rect')
                                .attr('width', exchangeWidth - 20)
                                .attr('height', config.routeHeight)
                                .attr('rx', 5)
                                .attr('fill', config.colors.route)
                                .attr('stroke', '#333')
                                .attr('stroke-width', 1);
                            
                            routeGroup.append('text')
                                .attr('x', 10)
                                .attr('y', 20)
                                .attr('fill', 'white')
                                .attr('font-size', '12px')
                                .attr('style', 'user-select: text; cursor: text;')
                                .text(`RoutingKey: ${route.name}`);
                            
                            // Очереди
                            let queueY = 40;
                            route.queues.forEach((queue, queueIndex) => {
                                const queueGroup = routeGroup.append('g')
                                    .attr('class', 'queue')
                                    .attr('transform', `translate(20, ${queueY})`);
                                
                                // Рассчитываем цвет на основе количества очередей в роуте
                                const queueColor = getQueueColor(route.queueCount, route.maxQueuesInRoute);
                                
                                queueGroup.append('rect')
                                    .attr('width', exchangeWidth - 40)
                                    .attr('height', config.queueHeight)
                                    .attr('rx', 3)
                                    .attr('fill', queueColor)
                                    .attr('stroke', '#333')
                                    .attr('stroke-width', 1);
                                
                                queueGroup.append('text')
                                    .attr('x', 10)
                                    .attr('y', 16)
                                    .attr('fill', 'white')
                                    .attr('font-size', '10px')
                                    .attr('style', 'user-select: text; cursor: text;')
                                    .text(queue.name);
                                
                                queueY += 30;
                            });
                            
                            // Переходим к следующему роуту
                            routeY += 40 + (route.queues.length * 30);
                        });
                        
                        // Переходим к следующему exchange горизонтально
                        exchangeX += exchangeWidth + 20;
                    });
                });
            } catch (error) {
                console.error('Ошибка рисования блоков:', error);
                g.append('text')
                    .attr('x', '50%')
                    .attr('y', '50%')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .attr('font-size', '16px')
                    .attr('fill', '#ff0000')
                    .text('Ошибка отображения блоков');
            }
        }
        
        // Функция для расчета цвета очереди на основе количества очередей в роуте
        function getQueueColor(queueCount, maxQueuesInRoute) {
            if (maxQueuesInRoute <= 1) {
                return '#2196F3'; // Светло-синий для одного элемента
            }
            
            // Рассчитываем интенсивность от 0.3 (светлый) до 1.0 (темный)
            // queueCount всегда равен maxQueuesInRoute для одного роута, поэтому используем фиксированную интенсивность
            const intensity = 0.3 + (0.7 * Math.min(queueCount / 5, 1)); // Максимум при 5+ очередях
            
            // Конвертируем в RGB
            const blue = Math.floor(243 * intensity);
            const green = Math.floor(150 * intensity);
            const red = Math.floor(33 * intensity);
            
            return `rgb(${red}, ${green}, ${blue})`;
        }
        
        // Функция для сворачивания статистики
        function toggleStats() {
            const stats = document.getElementById('stats');
            const toggle = document.getElementById('statsToggle');
            
            if (stats.classList.contains('collapsed')) {
                stats.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                stats.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }
        
        // Функция для сворачивания фильтров
        function toggleFilters() {
            const filters = document.getElementById('filters');
            const toggle = document.getElementById('filtersToggle');
            
            if (filters.classList.contains('collapsed')) {
                filters.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                filters.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }
        
        // Обновление статистики
        function updateStats() {
            try {
                const exchanges = topology.exchanges || [];
                const queues = topology.queues || [];
                const bindings = topology.bindings || [];
                
                // Применяем фильтры к данным для статистики
                const filteredExchanges = exchanges.filter(exchange => {
                    if (currentFilters.virtualHost && exchange.vhost !== currentFilters.virtualHost) {
                        return false;
                    }
                    if (currentFilters.exchange && exchange.name !== currentFilters.exchange) {
                        return false;
                    }
                    return true;
                });
                
                const filteredQueues = queues.filter(queue => {
                    if (currentFilters.virtualHost && queue.vhost !== currentFilters.virtualHost) {
                        return false;
                    }
                    if (currentFilters.queue && queue.name !== currentFilters.queue) {
                        return false;
                    }
                    return true;
                });
                
                const filteredBindings = bindings.filter(binding => {
                    if (currentFilters.virtualHost && binding.vhost !== currentFilters.virtualHost) {
                        return false;
                    }
                    if (currentFilters.exchange && binding.source !== currentFilters.exchange) {
                        return false;
                    }
                    if (currentFilters.route && binding.routing_key !== currentFilters.route) {
                        return false;
                    }
                    if (currentFilters.queue && binding.destination !== currentFilters.queue) {
                        return false;
                    }
                    return true;
                });
                
                // Подсчитываем уникальные VirtualHost из отфильтрованных данных
                const virtualHosts = new Set();
                filteredExchanges.forEach(exchange => {
                    virtualHosts.add(exchange.vhost || '/');
                });
                filteredQueues.forEach(queue => {
                    virtualHosts.add(queue.vhost || '/');
                });
                
                // Находим связанные с bindings exchange и считаем уникальные
                const exchangeByName = new Map(filteredExchanges.map(ex => [ex.name, ex]));
                const relatedExchanges = new Set();
                filteredBindings.forEach(binding => {
                    if (binding.source && exchangeByName.has(binding.source)) {
                        relatedExchanges.add(binding.source);
                    }
                });
                
                // Подсчитываем Route (уникальные routing_key из отфильтрованных bindings)
                const routes = new Set();
                filteredBindings.forEach(binding => {
                    if (binding.destination_type === 'queue' && binding.routing_key) {
                        routes.add(binding.routing_key);
                    }
                });
                
                // Подсчитываем многопользовательские Route (routing_key с несколькими queue)
                const routeQueueCount = {};
                filteredBindings.forEach(binding => {
                    if (binding.destination_type === 'queue' && binding.routing_key) {
                        const routeKey = binding.routing_key;
                        routeQueueCount[routeKey] = (routeQueueCount[routeKey] || 0) + 1;
                    }
                });
                const multiQueueRoutes = Object.values(routeQueueCount).filter(count => count > 1).length;
                
                // Подсчитываем уникальные очереди из отфильтрованных bindings
                const uniqueQueues = new Set();
                filteredBindings.forEach(binding => {
                    if (binding.destination_type === 'queue') {
                        uniqueQueues.add(binding.destination);
                    }
                });
                
                // Обновляем элементы статистики
                document.getElementById('virtualHostCount').textContent = virtualHosts.size;
                // Считаем количество только связанных Exchange, если есть bindings; иначе показываем количество отфильтрованных exchanges
                const exchangeCount = relatedExchanges.size > 0 ? relatedExchanges.size : filteredExchanges.length;
                document.getElementById('exchangeCount').textContent = exchangeCount;
                document.getElementById('queueCount').textContent = uniqueQueues.size;
                document.getElementById('routeCount').textContent = routes.size;
                document.getElementById('multiQueueRouteCount').textContent = multiQueueRoutes;
                
            } catch (error) {
                console.error('Ошибка обновления статистики:', error);
            }
        }
        
        // Настройка фильтров
        function setupFilters() {
            const exchanges = topology.exchanges || [];
            const queues = topology.queues || [];
            const bindings = topology.bindings || [];
            
            // Получаем элементы фильтров
            const virtualHostFilter = document.getElementById('virtualHostFilter');
            const exchangeFilter = document.getElementById('exchangeFilter');
            const routeFilter = document.getElementById('routeFilter');
            const queueFilter = document.getElementById('queueFilter');
            const virtualHostReset = document.getElementById('virtualHostReset');
            const exchangeReset = document.getElementById('exchangeReset');
            const routeReset = document.getElementById('routeReset');
            const queueReset = document.getElementById('queueReset');
            const virtualHostOpen = document.getElementById('virtualHostOpen');
            const exchangeOpen = document.getElementById('exchangeOpen');
            const routeOpen = document.getElementById('routeOpen');
            const queueOpen = document.getElementById('queueOpen');
            
            // Получаем элементы datalist
            const virtualHostList = document.getElementById('virtualHostList');
            const exchangeList = document.getElementById('exchangeList');
            const routeList = document.getElementById('routeList');
            const queueList = document.getElementById('queueList');
            
            // Сохраняем текущие значения фильтров
            const currentVirtualHost = virtualHostFilter.value;
            const currentExchange = exchangeFilter.value;
            const currentRoute = routeFilter.value;
            const currentQueue = queueFilter.value;
            
            // Очищаем datalist
            virtualHostList.innerHTML = '';
            exchangeList.innerHTML = '';
            routeList.innerHTML = '';
            queueList.innerHTML = '';
            
            // Заполняем datalist VirtualHost
            const virtualHosts = new Set();
            exchanges.forEach(exchange => {
                virtualHosts.add(exchange.vhost || '/');
            });
            queues.forEach(queue => {
                virtualHosts.add(queue.vhost || '/');
            });
            virtualHosts.forEach(vhost => {
                const option = document.createElement('option');
                option.value = vhost;
                virtualHostList.appendChild(option);
            });
            
            // Заполняем datalist обменов
            exchanges.forEach(exchange => {
                const option = document.createElement('option');
                option.value = exchange.name;
                exchangeList.appendChild(option);
            });
            
            // Заполняем datalist очередей
            queues.forEach(queue => {
                const option = document.createElement('option');
                option.value = queue.name;
                queueList.appendChild(option);
            });
            
            // Заполняем datalist роутов
            const routes = new Set();
            bindings.forEach(binding => {
                if (binding.routing_key) {
                    routes.add(binding.routing_key);
                }
            });
            routes.forEach(route => {
                const option = document.createElement('option');
                option.value = route;
                routeList.appendChild(option);
            });
            
            // Удаляем старые обработчики событий
            const oldVirtualHostFilter = virtualHostFilter.cloneNode(true);
            const oldExchangeFilter = exchangeFilter.cloneNode(true);
            const oldRouteFilter = routeFilter.cloneNode(true);
            const oldQueueFilter = queueFilter.cloneNode(true);
            
            virtualHostFilter.parentNode.replaceChild(oldVirtualHostFilter, virtualHostFilter);
            exchangeFilter.parentNode.replaceChild(oldExchangeFilter, exchangeFilter);
            routeFilter.parentNode.replaceChild(oldRouteFilter, routeFilter);
            queueFilter.parentNode.replaceChild(oldQueueFilter, queueFilter);
            
            // Получаем новые элементы после замены
            const newVirtualHostFilter = document.getElementById('virtualHostFilter');
            const newExchangeFilter = document.getElementById('exchangeFilter');
            const newRouteFilter = document.getElementById('routeFilter');
            const newQueueFilter = document.getElementById('queueFilter');
            
            // Обработчики фильтров (одноразовые, без накопления)
            newVirtualHostFilter.oninput = (e) => {
                currentFilters.virtualHost = e.target.value;
                updateVisualization();
            };
            
            newExchangeFilter.oninput = (e) => {
                currentFilters.exchange = e.target.value;
                updateVisualization();
            };
            
            newRouteFilter.oninput = (e) => {
                currentFilters.route = e.target.value;
                updateVisualization();
            };
            
            newQueueFilter.oninput = (e) => {
                currentFilters.queue = e.target.value;
                updateVisualization();
            };
            
            // Кнопки сброса (переназначаем обработчики, чтобы не накапливались)
            virtualHostReset.onclick = null;
            virtualHostReset.onclick = () => {
                newVirtualHostFilter.value = '';
                currentFilters.virtualHost = '';
                updateVisualization();
            };
            exchangeReset.onclick = null;
            exchangeReset.onclick = () => {
                newExchangeFilter.value = '';
                currentFilters.exchange = '';
                updateVisualization();
            };
            routeReset.onclick = null;
            routeReset.onclick = () => {
                newRouteFilter.value = '';
                currentFilters.route = '';
                updateVisualization();
            };
            queueReset.onclick = null;
            queueReset.onclick = () => {
                newQueueFilter.value = '';
                currentFilters.queue = '';
                updateVisualization();
            };

            // Кнопки открытия списка (фокус + раскрытие подсказок)
            function openDatalist(inputEl) {
                inputEl.focus();
                // триггерим событие ввода, чтобы браузер показал варианты
                const val = inputEl.value;
                inputEl.value = '';
                inputEl.dispatchEvent(new Event('input', { bubbles: true }));
                setTimeout(() => {
                    inputEl.value = val;
                    inputEl.dispatchEvent(new Event('input', { bubbles: true }));
                }, 0);
            }
            virtualHostOpen.onclick = () => openDatalist(newVirtualHostFilter);
            exchangeOpen.onclick = () => openDatalist(newExchangeFilter);
            routeOpen.onclick = () => openDatalist(newRouteFilter);
            queueOpen.onclick = () => openDatalist(newQueueFilter);
            
            // Восстанавливаем сохраненные значения
            if (currentVirtualHost) {
                newVirtualHostFilter.value = currentVirtualHost;
                currentFilters.virtualHost = currentVirtualHost;
            }
            if (currentExchange) {
                newExchangeFilter.value = currentExchange;
                currentFilters.exchange = currentExchange;
            }
            if (currentRoute) {
                newRouteFilter.value = currentRoute;
                currentFilters.route = currentRoute;
            }
            if (currentQueue) {
                newQueueFilter.value = currentQueue;
                currentFilters.queue = currentQueue;
            }
        }
        
        // Обработчики кнопок
        document.getElementById('refreshBtn').addEventListener('click', () => {
            updateVisualization();
        });
        
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            if (svg && zoom) {
                svg.transition().call(zoom.scaleBy, 1.5);
            }
        });
        
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            if (svg && zoom) {
                svg.transition().call(zoom.scaleBy, 1 / 1.5);
            }
        });
        
        // Инициализация при загрузке страницы
        window.addEventListener('load', () => {
            if (typeof d3 !== 'undefined') {
                initVisualization();
            } else {
                console.error('D3.js не загружен');
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка загрузки D3.js</h2><p>Библиотека D3.js не загружена</p></div>';
            }
        });
    </script>
</body>
</html>
