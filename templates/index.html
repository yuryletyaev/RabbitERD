<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RabbitMQ ERD Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="/static/css/style.css">
    <style>
        .filters-container {
            margin: 10px 0;
        }
        
        .filters-header {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        .filters-header:hover {
            background: #e5e5e5;
        }
        
        .filters-toggle {
            font-size: 16px;
            transition: transform 0.3s ease;
        }
        
        .filters-toggle.collapsed {
            transform: rotate(-90deg);
        }
        
        .filters {
            display: flex;
            gap: 20px;
            margin: 10px 0;
            flex-wrap: wrap;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .filters.collapsed {
            max-height: 0;
            margin: 0;
            opacity: 0;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .filter-group label {
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }
        
        .filter-group select {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .exchange-block {
            cursor: pointer;
        }
        
        .route {
            cursor: pointer;
        }
        
        .queue {
            cursor: pointer;
        }
        
        .exchange-block:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 3 !important;
        }
        
        .route:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 2 !important;
        }
        
        .queue:hover rect {
            stroke: #FFD700 !important;
            stroke-width: 2 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>RabbitMQ ERD Visualizer</h1>
            <div class="controls">
                <button id="refreshBtn" class="btn">Обновить</button>
                <button id="zoomInBtn" class="btn">+</button>
                <button id="zoomOutBtn" class="btn">-</button>
            </div>
        </header>
        
        <div class="info-panel">
            <div class="stats">
                <div class="stat-item">
                    <span class="label">Обмены:</span>
                    <span class="value" id="exchangeCount">{{ topology.exchanges|length }}</span>
                </div>
                <div class="stat-item">
                    <span class="label">Очереди:</span>
                    <span class="value" id="queueCount">{{ topology.queues|length }}</span>
                </div>
                <div class="stat-item">
                    <span class="label">Связи:</span>
                    <span class="value" id="connectionCount">{{ topology.connections|length }}</span>
                </div>
            </div>
            <div class="filters-container">
                <div class="filters-header" onclick="toggleFilters()">
                    <span class="filters-toggle" id="filtersToggle">▼</span>
                    <span>Фильтры</span>
                </div>
                <div class="filters" id="filters">
                    <div class="filter-group">
                        <label>Фильтр по VirtualHost:</label>
                        <select id="virtualHostFilter">
                            <option value="">Все VirtualHost</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Фильтр по Exchanges:</label>
                        <select id="exchangeFilter">
                            <option value="">Все Exchanges</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Фильтр по RoutingKey:</label>
                        <select id="routeFilter">
                            <option value="">Все RoutingKey</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Фильтр по очередям:</label>
                        <select id="queueFilter">
                            <option value="">Все очереди</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="visualization-container">
            <svg id="diagram" width="100%" height="600"></svg>
        </div>
        
        <div class="details-panel" id="detailsPanel" style="display: none;">
            <h3>Детали</h3>
            <div id="detailsContent"></div>
        </div>
    </div>
    
    <script>
        // Данные топологии
        const topology = {{ topology | tojson }};
        
        // Конфигурация
        const config = {
            virtualHostWidth: 400,
            virtualHostHeight: 400,
            blockWidth: 300,
            blockHeight: 300,
            routeHeight: 35,
            queueHeight: 25,
            colors: {
                virtualHost: 'transparent',
                exchange: 'transparent',
                route: '#FF9800',
                queue: '#2196F3',
                connection: '#666'
            }
        };
        
        // Глобальные переменные
        let svg, g, zoom;
        let currentFilters = {
            virtualHost: '',
            exchange: '',
            route: '',
            queue: ''
        };
        
        // Инициализация визуализации
        function initVisualization() {
            try {
                svg = d3.select('#diagram');
                g = svg.append('g');
                
                zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                
                updateVisualization();
            } catch (error) {
                console.error('Ошибка инициализации:', error);
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка инициализации</h2><p>' + error.message + '</p>';
            }
        }
        
        // Обновление визуализации
        function updateVisualization() {
            try {
                if (!topology) {
                    console.error('Данные топологии не загружены');
                    return;
                }
                
                g.selectAll('*').remove();
                
                const exchanges = topology.exchanges || [];
                const queues = topology.queues || [];
                const bindings = topology.bindings || [];
                
                if (exchanges.length === 0 && queues.length === 0) {
                    g.append('text')
                        .attr('x', '50%')
                        .attr('y', '50%')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '0.35em')
                        .attr('font-size', '18px')
                        .attr('fill', '#666')
                        .text('Нет данных для отображения');
                    return;
                }
                
                // Создаем структуру данных
                const virtualHostBlocks = createVirtualHostBlocks(exchanges, queues, bindings);
                
                // Фильтруем данные
                const filteredBlocks = filterVirtualHostBlocks(virtualHostBlocks);
                
                // Рисуем блоки
                drawVirtualHostBlocks(filteredBlocks);
                
                // Настраиваем фильтры после обновления данных
                setupFilters();
                
            } catch (error) {
                console.error('Ошибка обновления визуализации:', error);
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка визуализации</h2><p>' + error.message + '</p></div>';
            }
        }
        
        // Создание блоков VirtualHost
        function createVirtualHostBlocks(exchanges, queues, bindings) {
            // Группируем по VirtualHost
            const virtualHosts = {};
            
            // Добавляем exchanges в VirtualHost
            exchanges.forEach(exchange => {
                const vhost = exchange.vhost || '/';
                if (!virtualHosts[vhost]) {
                    virtualHosts[vhost] = {
                        name: vhost,
                        exchanges: []
                    };
                }
                virtualHosts[vhost].exchanges.push(exchange);
            });
            
            // Добавляем queues в VirtualHost
            queues.forEach(queue => {
                const vhost = queue.vhost || '/';
                if (!virtualHosts[vhost]) {
                    virtualHosts[vhost] = {
                        name: vhost,
                        exchanges: []
                    };
                }
            });
            
            // Создаем структуру для каждого VirtualHost
            return Object.values(virtualHosts).map((vhost, index) => {
                const vhostExchanges = vhost.exchanges.map(exchange => {
                    // Находим связанные очереди через bindings
                    const relatedBindings = bindings.filter(binding => 
                        binding.source === exchange.name || binding.destination === exchange.name
                    );
                    
                    // Группируем по роутам (routing_key)
                    const routes = {};
                    relatedBindings.forEach(binding => {
                        const routeKey = binding.routing_key || 'default';
                        if (!routes[routeKey]) {
                            routes[routeKey] = [];
                        }
                        routes[routeKey].push(binding);
                    });
                    
                    // Создаем структуру роутов
                    const routeList = Object.keys(routes).map(routeKey => {
                        const routeBindings = routes[routeKey];
                        const routeQueues = routeBindings.map(binding => {
                            const queueName = binding.destination === exchange.name ? 
                                binding.source : binding.destination;
                            return queues.find(q => q.name === queueName);
                        }).filter(q => q);
                        
                        return {
                            name: routeKey,
                            queues: routeQueues,
                            bindings: routeBindings,
                            queueCount: routeQueues.length
                        };
                    });
                    
                    // Для каждого роута устанавливаем максимальное количество очередей в этом роуте
                    routeList.forEach(route => {
                        route.maxQueuesInRoute = route.queueCount; // Максимум очередей в этом конкретном роуте
                    });
                    
                    return {
                        exchange: exchange,
                        routes: routeList
                    };
                });
                
                return {
                    virtualHost: vhost,
                    exchanges: vhostExchanges,
                    x: 50 + index * 500,
                    y: 50
                };
            });
        }
        
        // Фильтрация блоков VirtualHost
        function filterVirtualHostBlocks(blocks) {
            return blocks.filter(block => {
                if (currentFilters.virtualHost && block.virtualHost.name !== currentFilters.virtualHost) {
                    return false;
                }
                
                if (currentFilters.exchange) {
                    const hasMatchingExchange = block.exchanges.some(exchange => 
                        exchange.exchange.name === currentFilters.exchange
                    );
                    if (!hasMatchingExchange) return false;
                }
                
                if (currentFilters.route) {
                    const hasMatchingRoute = block.exchanges.some(exchange =>
                        exchange.routes.some(route => route.name === currentFilters.route)
                    );
                    if (!hasMatchingRoute) return false;
                }
                
                if (currentFilters.queue) {
                    const hasMatchingQueue = block.exchanges.some(exchange =>
                        exchange.routes.some(route =>
                            route.queues.some(queue => queue.name === currentFilters.queue)
                        )
                    );
                    if (!hasMatchingQueue) return false;
                }
                
                return true;
            });
        }
        
        // Рисование блоков VirtualHost
        function drawVirtualHostBlocks(blocks) {
            try {
                const virtualHostGroups = g.append('g')
                    .attr('class', 'virtualhost-blocks')
                    .selectAll('g')
                    .data(blocks)
                    .enter().append('g')
                    .attr('class', 'virtualhost-block')
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);
                
                // Рассчитываем размеры блока VirtualHost динамически
                blocks.forEach((block, blockIndex) => {
                    const currentVirtualHostGroup = virtualHostGroups.filter(d => d === block);
                    
                    // Рассчитываем высоту на основе содержимого (максимальная высота среди всех exchanges)
                    let maxHeight = 80; // Заголовок + отступы
                    let totalWidth = 40; // Отступы
                    
                    block.exchanges.forEach(exchangeData => {
                        // Рассчитываем размеры exchange на основе содержимого
                        let exchangeWidth = 200; // Минимальная ширина
                        let exchangeHeight = 50; // Высота заголовка
                        
                        // Учитываем длину названия Exchange
                        const exchangeNameWidth = Math.max(200, exchangeData.exchange.name.length * 8 + 100);
                        exchangeWidth = Math.max(exchangeWidth, exchangeNameWidth);
                        
                        exchangeData.routes.forEach(route => {
                            const routeWidth = Math.max(150, route.name.length * 8 + 100);
                            exchangeWidth = Math.max(exchangeWidth, routeWidth + 20);
                            
                            exchangeHeight += 40; // Высота route
                            
                            route.queues.forEach(queue => {
                                const queueWidth = Math.max(100, queue.name.length * 6 + 80);
                                exchangeWidth = Math.max(exchangeWidth, queueWidth + 40);
                                
                                exchangeHeight += 30; // Высота очереди
                            });
                        });
                        
                        // Обновляем общие размеры VirtualHost
                        maxHeight = Math.max(maxHeight, exchangeHeight + 80);
                        totalWidth += exchangeWidth + 20; // Ширина exchange + отступ
                    });
                    
                    // Рисуем основной блок VirtualHost с рассчитанными размерами
                    currentVirtualHostGroup.append('rect')
                        .attr('width', totalWidth)
                        .attr('height', maxHeight)
                        .attr('rx', 15)
                        .attr('fill', config.colors.virtualHost)
                        .attr('stroke', '#333')
                        .attr('stroke-width', 3);
                    
                    // Обновляем размеры блока в данных
                    block.width = totalWidth;
                    block.height = maxHeight;
                });
                
                // Заголовок VirtualHost для каждого блока отдельно
                blocks.forEach((block, blockIndex) => {
                    const currentVirtualHostGroup = virtualHostGroups.filter(d => d === block);
                    
                    currentVirtualHostGroup.append('text')
                        .attr('x', block.width / 2)
                        .attr('y', 30)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#333')
                        .attr('font-weight', 'bold')
                        .attr('font-size', '16px')
                        .text(`VirtualHost: ${block.virtualHost.name}`);
                });
                
                // Рисуем содержимое для каждого VirtualHost отдельно
                blocks.forEach((block, blockIndex) => {
                    const currentVirtualHostGroup = virtualHostGroups.filter(d => d === block);
                    let exchangeX = 20;
                    
                    block.exchanges.forEach((exchangeData, exchangeIndex) => {
                        // Рассчитываем размеры exchange на основе содержимого
                        let exchangeWidth = 200; // Минимальная ширина
                        let exchangeHeight = 50; // Высота заголовка
                        
                        // Учитываем длину названия Exchange
                        const exchangeNameWidth = Math.max(200, exchangeData.exchange.name.length * 8 + 100);
                        exchangeWidth = Math.max(exchangeWidth, exchangeNameWidth);
                        
                        exchangeData.routes.forEach(route => {
                            const routeWidth = Math.max(150, route.name.length * 8 + 100);
                            exchangeWidth = Math.max(exchangeWidth, routeWidth + 20);
                            
                            exchangeHeight += 40; // Высота route
                            
                            route.queues.forEach(queue => {
                                const queueWidth = Math.max(100, queue.name.length * 6 + 80);
                                exchangeWidth = Math.max(exchangeWidth, queueWidth + 40);
                                
                                exchangeHeight += 30; // Высота очереди
                            });
                        });
                        
                        const exchangeGroup = currentVirtualHostGroup.append('g')
                            .attr('class', 'exchange')
                            .attr('transform', `translate(${exchangeX}, 60)`);
                        
                        // Exchange с рассчитанными размерами
                        exchangeGroup.append('rect')
                            .attr('width', exchangeWidth)
                            .attr('height', exchangeHeight)
                            .attr('rx', 10)
                            .attr('fill', config.colors.exchange)
                            .attr('stroke', '#333')
                            .attr('stroke-width', 2);
                        
                        exchangeGroup.append('text')
                            .attr('x', 10)
                            .attr('y', 25)
                            .attr('fill', '#333')
                            .attr('font-weight', 'bold')
                            .attr('font-size', '14px')
                            .text(`Exchange: ${exchangeData.exchange.name}`);
                        
                        // Рисуем роуты для каждого exchange
                        let routeY = 50;
                        exchangeData.routes.forEach((route, routeIndex) => {
                            const routeGroup = exchangeGroup.append('g')
                                .attr('class', 'route')
                                .attr('transform', `translate(10, ${routeY})`);
                            
                            // Роут
                            routeGroup.append('rect')
                                .attr('width', exchangeWidth - 20)
                                .attr('height', config.routeHeight)
                                .attr('rx', 5)
                                .attr('fill', config.colors.route)
                                .attr('stroke', '#333')
                                .attr('stroke-width', 1);
                            
                            routeGroup.append('text')
                                .attr('x', 10)
                                .attr('y', 20)
                                .attr('fill', 'white')
                                .attr('font-size', '12px')
                                .text(`RoutingKey: ${route.name}`);
                            
                            // Очереди
                            let queueY = 40;
                            route.queues.forEach((queue, queueIndex) => {
                                const queueGroup = routeGroup.append('g')
                                    .attr('class', 'queue')
                                    .attr('transform', `translate(20, ${queueY})`);
                                
                                // Рассчитываем цвет на основе количества очередей в роуте
                                const queueColor = getQueueColor(route.queueCount, route.maxQueuesInRoute);
                                
                                queueGroup.append('rect')
                                    .attr('width', exchangeWidth - 40)
                                    .attr('height', config.queueHeight)
                                    .attr('rx', 3)
                                    .attr('fill', queueColor)
                                    .attr('stroke', '#333')
                                    .attr('stroke-width', 1);
                                
                                queueGroup.append('text')
                                    .attr('x', 10)
                                    .attr('y', 16)
                                    .attr('fill', 'white')
                                    .attr('font-size', '10px')
                                    .text(queue.name);
                                
                                queueY += 30;
                            });
                            
                            // Переходим к следующему роуту
                            routeY += 40 + (route.queues.length * 30);
                        });
                        
                        // Переходим к следующему exchange горизонтально
                        exchangeX += exchangeWidth + 20;
                    });
                });
            } catch (error) {
                console.error('Ошибка рисования блоков:', error);
                g.append('text')
                    .attr('x', '50%')
                    .attr('y', '50%')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .attr('font-size', '16px')
                    .attr('fill', '#ff0000')
                    .text('Ошибка отображения блоков');
            }
        }
        
        // Функция для расчета цвета очереди на основе количества очередей в роуте
        function getQueueColor(queueCount, maxQueuesInRoute) {
            if (maxQueuesInRoute <= 1) {
                return '#2196F3'; // Светло-синий для одного элемента
            }
            
            // Рассчитываем интенсивность от 0.3 (светлый) до 1.0 (темный)
            // queueCount всегда равен maxQueuesInRoute для одного роута, поэтому используем фиксированную интенсивность
            const intensity = 0.3 + (0.7 * Math.min(queueCount / 5, 1)); // Максимум при 5+ очередях
            
            // Конвертируем в RGB
            const blue = Math.floor(243 * intensity);
            const green = Math.floor(150 * intensity);
            const red = Math.floor(33 * intensity);
            
            return `rgb(${red}, ${green}, ${blue})`;
        }
        
        // Функция для сворачивания фильтров
        function toggleFilters() {
            const filters = document.getElementById('filters');
            const toggle = document.getElementById('filtersToggle');
            
            if (filters.classList.contains('collapsed')) {
                filters.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                filters.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }
        
        // Настройка фильтров
        function setupFilters() {
            const exchanges = topology.exchanges || [];
            const queues = topology.queues || [];
            const bindings = topology.bindings || [];
            
            // Очищаем фильтры
            const virtualHostFilter = document.getElementById('virtualHostFilter');
            const exchangeFilter = document.getElementById('exchangeFilter');
            const routeFilter = document.getElementById('routeFilter');
            const queueFilter = document.getElementById('queueFilter');
            
            // Очищаем опции
            virtualHostFilter.innerHTML = '<option value="">Все VirtualHost</option>';
            exchangeFilter.innerHTML = '<option value="">Все Exchanges</option>';
            routeFilter.innerHTML = '<option value="">Все RoutingKey</option>';
            queueFilter.innerHTML = '<option value="">Все очереди</option>';
            
            // Заполняем фильтр VirtualHost
            const virtualHosts = new Set();
            exchanges.forEach(exchange => {
                virtualHosts.add(exchange.vhost || '/');
            });
            queues.forEach(queue => {
                virtualHosts.add(queue.vhost || '/');
            });
            virtualHosts.forEach(vhost => {
                const option = document.createElement('option');
                option.value = vhost;
                option.textContent = vhost;
                virtualHostFilter.appendChild(option);
            });
            
            // Заполняем фильтр обменов
            const exchangeFilter = document.getElementById('exchangeFilter');
            exchanges.forEach(exchange => {
                const option = document.createElement('option');
                option.value = exchange.name;
                option.textContent = exchange.name;
                exchangeFilter.appendChild(option);
            });
            
            // Заполняем фильтр очередей
            const queueFilter = document.getElementById('queueFilter');
            queues.forEach(queue => {
                const option = document.createElement('option');
                option.value = queue.name;
                option.textContent = queue.name;
                queueFilter.appendChild(option);
            });
            
            // Заполняем фильтр роутов
            const routeFilter = document.getElementById('routeFilter');
            const routes = new Set();
            bindings.forEach(binding => {
                if (binding.routing_key) {
                    routes.add(binding.routing_key);
                }
            });
            routes.forEach(route => {
                const option = document.createElement('option');
                option.value = route;
                option.textContent = route;
                routeFilter.appendChild(option);
            });
            
            // Обработчики фильтров
            virtualHostFilter.addEventListener('change', (e) => {
                currentFilters.virtualHost = e.target.value;
                updateVisualization();
            });
            
            exchangeFilter.addEventListener('change', (e) => {
                currentFilters.exchange = e.target.value;
                updateVisualization();
            });
            
            routeFilter.addEventListener('change', (e) => {
                currentFilters.route = e.target.value;
                updateVisualization();
            });
            
            queueFilter.addEventListener('change', (e) => {
                currentFilters.queue = e.target.value;
                updateVisualization();
            });
        }
        
        // Обработчики кнопок
        document.getElementById('refreshBtn').addEventListener('click', () => {
            updateVisualization();
        });
        
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            if (svg && zoom) {
                svg.transition().call(zoom.scaleBy, 1.5);
            }
        });
        
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            if (svg && zoom) {
                svg.transition().call(zoom.scaleBy, 1 / 1.5);
            }
        });
        
        // Инициализация при загрузке страницы
        window.addEventListener('load', () => {
            if (typeof d3 !== 'undefined') {
                initVisualization();
            } else {
                console.error('D3.js не загружен');
                document.querySelector('.visualization-container').innerHTML = 
                    '<div class="error-container"><h2>Ошибка загрузки D3.js</h2><p>Библиотека D3.js не загружена</p></div>';
            }
        });
    </script>
</body>
</html>
