<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест без RabbitMQ</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        #diagram { width: 100%; height: 400px; border: 1px solid #ccc; }
        .success { color: green; }
        .error { color: red; }
    </style>
</head>
<body>
    <h1>Тест визуализации без RabbitMQ</h1>
    <div id="status"></div>
    <svg id="diagram" width="100%" height="400"></svg>
    
    <script>
        // Тестовые данные (имитация пустой топологии)
        const topology = {
            exchanges: [],
            queues: [],
            bindings: [],
            connections: []
        };
        
        // Настройки
        const config = {
            nodeWidth: 200,
            nodeHeight: 100,
            spacing: 150,
            colors: {
                exchange: '#4CAF50',
                queue: '#2196F3',
                connection: '#FF9800'
            }
        };
        
        let svg, g, zoom, simulation;
        
        function initVisualization() {
            try {
                const status = document.getElementById('status');
                
                // Проверка D3
                if (typeof d3 === 'undefined') {
                    status.innerHTML = '<p class="error">❌ D3.js не загружен</p>';
                    return;
                }
                
                status.innerHTML = '<p class="success">✅ D3.js загружен</p>';
                
                svg = d3.select('#diagram');
                g = svg.append('g');
                
                // Настройка зума
                zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                
                // Создание симуляции
                simulation = d3.forceSimulation()
                    .force('link', d3.forceLink().id(d => d.id).distance(200))
                    .force('charge', d3.forceManyBody().strength(-300))
                    .force('center', d3.forceCenter(svg.node().clientWidth / 2, svg.node().clientHeight / 2));
                
                updateVisualization();
                
            } catch (error) {
                console.error('Ошибка инициализации:', error);
                document.getElementById('status').innerHTML += `<p class="error">❌ Ошибка: ${error.message}</p>`;
            }
        }
        
        function updateVisualization() {
            try {
                const nodes = [];
                const links = topology.connections || [];
                
                // Проверка на пустые данные
                if (nodes.length === 0) {
                    console.log('Нет данных для отображения');
                    g.append('text')
                        .attr('x', '50%')
                        .attr('y', '50%')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '0.35em')
                        .attr('font-size', '18px')
                        .attr('fill', '#666')
                        .text('Нет данных для отображения');
                    return;
                }
                
                // Очистка предыдущих элементов
                g.selectAll('*').remove();
                
                // Создание связей
                const link = g.append('g')
                    .attr('class', 'links')
                    .selectAll('line')
                    .data(links)
                    .enter().append('line')
                    .attr('stroke', config.colors.connection)
                    .attr('stroke-width', 2)
                    .attr('stroke-opacity', 0.8);
                
                // Создание узлов
                const node = g.append('g')
                    .attr('class', 'nodes')
                    .selectAll('g')
                    .data(nodes)
                    .enter().append('g')
                    .attr('class', 'node');
                
                // Прямоугольники
                node.append('rect')
                    .attr('width', config.nodeWidth)
                    .attr('height', config.nodeHeight)
                    .attr('rx', 10)
                    .attr('fill', d => d.type === 'exchange' ? config.colors.exchange : config.colors.queue)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 2);
                
                // Текст
                node.append('text')
                    .attr('x', config.nodeWidth / 2)
                    .attr('y', config.nodeHeight / 2)
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .attr('fill', 'white')
                    .attr('font-weight', 'bold')
                    .attr('font-size', '12px')
                    .text(d => d.name);
                
                // Обновление симуляции
                simulation.nodes(nodes);
                simulation.force('link').links(links);
                simulation.on('tick', () => {
                    node.attr('transform', d => {
                        const x = d.x || 0;
                        const y = d.y || 0;
                        return `translate(${x - config.nodeWidth/2}, ${y - config.nodeHeight/2})`;
                    });
                });
                
                simulation.alpha(1).restart();
                
                document.getElementById('status').innerHTML += '<p class="success">✅ Визуализация создана успешно</p>';
                
            } catch (error) {
                console.error('Ошибка обновления визуализации:', error);
                document.getElementById('status').innerHTML += `<p class="error">❌ Ошибка: ${error.message}</p>`;
            }
        }
        
        // Запуск при загрузке
        window.addEventListener('load', initVisualization);
    </script>
</body>
</html>
